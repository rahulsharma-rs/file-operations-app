{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 22, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/app/actions.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs/promises'\nimport path from 'path'\nimport os from 'os'\nimport { FileItem, SharedFileItem } from '@/app/types'\n\nconst BASE_PATH = os.homedir()\nconst ALLOWED_ROOTS = [os.homedir(), '/data', '/scratch', '/gpfs', '/fs1', '/project', '/work', '/lstr']\n\nexport async function getFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        // Construct path from segments. \n        // We resolve (...) segments relative to BASE_PATH (Home).\n        // If segments are ['..', '..', 'data'], it resolves to /data\n\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(BASE_PATH, relativePath)\n        const resolvedPath = path.resolve(fullPath)\n\n        // Security Check: \n        // Allow if it is within Home OR starts with any of the allowed HPC roots.\n        // We strictly block sensitive system roots to prevent accidentally enumerating /proc or /etc\n        const isAllowed = ALLOWED_ROOTS.some(root => resolvedPath.startsWith(root)) ||\n            (resolvedPath !== '/' && !['/etc', '/var', '/usr', '/bin', '/sbin', '/proc', '/sys', '/boot'].some(restricted => resolvedPath.startsWith(restricted)))\n\n        if (!isAllowed) {\n            // Check for explicit allowed roots failed, and it hit a restricted block list or is root.\n            // Actually, the logic above is: OR (NOT restricted). \n            // So if it's /data (not restricted), it passes.\n            // If it's /etc (restricted), it fails unless it was in ALLOWED_ROOTS (unlikely).\n\n            // Double check safety:\n            if (resolvedPath === '/' || resolvedPath.startsWith('/etc') || resolvedPath.startsWith('/proc')) {\n                throw new Error(\"Access denied: Restricted system directory\")\n            }\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n                else if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n\n                // Permission string simulation (Node fs doesn't give \"rwx\" string directly easily across platforms, \n                // but we can approximate from mode)\n                const perms = (stats.mode & parseInt('777', 8)).toString(8) // simple octal\n\n                return {\n                    id: entryPath, // Use path as ID\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}` // Mocking the rwx string is complex, showing octal for now\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error reading directory:\", error)\n        return []\n    }\n}\n\n// ... imports\n\nexport async function getRelativePath(targetPath: string): Promise<string[]> {\n    const rel = path.relative(BASE_PATH, targetPath)\n    if (rel === '') return []\n    return rel.split(path.sep)\n}\n\nexport async function getDataPath(): Promise<string[]> {\n    const username = os.userInfo().username\n    const dataPath = path.join('/data/user', username)\n\n    // Ensure this path exists, if not maybe fallback to /data?\n    // user said \"path on my HPC is /data/user/$USER\", so we assume it exists\n\n    // Calculate relative path from Home (BASE_PATH)\n    const rel = path.relative(BASE_PATH, dataPath)\n    if (rel === '') return []\n    return rel.split(path.sep)\n}\n\nimport { exec } from 'child_process'\nimport util from 'util'\n\nconst execAsync = util.promisify(exec)\n\nconst usernameCache = new Map<number, string>()\n\nasync function getUsername(uid: number): Promise<string> {\n    if (usernameCache.has(uid)) return usernameCache.get(uid)!\n    try {\n        const { stdout } = await execAsync(`id -nu ${uid}`)\n        const name = stdout.trim()\n        usernameCache.set(uid, name)\n        return name\n    } catch (e) {\n        return String(uid)\n    }\n}\n\nasync function userExists(username: string): Promise<boolean> {\n    try {\n        await execAsync(`id -u ${username}`)\n        return true\n    } catch (error) {\n        return false\n    }\n}\n\nexport async function shareFile(sourcePath: string, targetUsername: string, permission: 'read' | 'write' = 'read'): Promise<{ success: boolean, message: string }> {\n    // Validate target user exists\n    if (!await userExists(targetUsername)) {\n        return { success: false, message: `User '${targetUsername}' does not exist on this system.` }\n    }\n\n    try {\n        // --- ACL IMPLEMENTATION ---\n        // Grant Read/Execute permissions to the target user on the source file/folder\n        // using 'setfacl'. This allows the target user to access the file directly via its full path.\n        // We do NOT create symlinks or 'hpc_shared' directories as per user request.\n\n        // Determine permissions string\n        // read: rx (needs x for directories to list contents)\n        // write: rwx (needs w to create/delete)\n        const aclPerms = permission === 'write' ? 'rwx' : 'rx'\n\n        // Determine if directory for recursive flag\n        const stats = await fs.stat(sourcePath)\n        const recursiveFlag = stats.isDirectory() ? '-R' : ''\n\n        // ...\n\n        try {\n            // 1. Apply ACL to the target file/folder\n            // Command: setfacl -R -m u:targetUser:rwx /path/to/source\n            await execAsync(`setfacl ${recursiveFlag} -m u:${targetUsername}:${aclPerms} \"${sourcePath}\"`)\n\n            // 2. Ensure Traversal Access (+x) on parent directories\n            // If the shared file is deep inside /data/user/alice/foo/bar,\n            // bob needs +x on /data/user/alice, /data/user/alice/foo to reach it.\n            // We ONLY do this for directories OWNED by the current user (e.g. inside Home or /data/user/$USER).\n\n            const currentUser = os.userInfo().username\n            const userRoots = [\n                os.homedir(),\n                path.join('/data/user', currentUser),\n                path.join('/scratch', currentUser)\n            ]\n\n            let currentDir = path.dirname(sourcePath)\n\n            // Walk up until we hit a system root or run out of path\n            while (currentDir !== '/' && currentDir !== '.') {\n                // Check if we are inside a user root\n                const isInsideUserRoot = userRoots.some(root => currentDir.startsWith(root))\n                if (!isInsideUserRoot) break; // Stop if we go above user's space (e.g. /data/user)\n\n                try {\n                    // Grant execute (x) ONLY. This allows traversal but not listing (r) or writing (w).\n                    // This is minimal privilege to reach the shared content.\n                    await execAsync(`setfacl -m u:${targetUsername}:x \"${currentDir}\"`)\n                } catch (e) {\n                    console.warn(`Failed to set traversal ACL on ${currentDir}:`, e)\n                    // Continue anyway, maybe it already works or we aren't owner (though we checked root)\n                }\n\n                currentDir = path.dirname(currentDir)\n            }\n\n            return { success: true, message: `Access granted to ${targetUsername} (${permission}). Traversal permissions updated.` }\n        } catch (aclError: any) {\n            console.error(\"ACL Error:\", aclError)\n            // If setfacl fails (e.g. local mac), we return error since this is the ONLY mechanism now.\n            if (process.env.NODE_ENV === 'development' && os.platform() === 'darwin') {\n                return { success: true, message: `[DEV] Simulating ACL grant (${aclPerms}) to ${targetUsername} for ${sourcePath}` }\n            }\n            return { success: false, message: `Failed to set permissions: ${aclError.message}` }\n        }\n    } catch (error: any) {\n        console.error(\"Error sharing file:\", error)\n        return { success: false, message: error.message || \"Failed to share file\" }\n    }\n}\n\nexport async function getFileAcls(filePath: string): Promise<{ username: string, permissions: 'read' | 'write' }[]> {\n    try {\n        if (!isPathAllowed(filePath)) throw new Error(\"Access denied\")\n\n        const { stdout } = await execAsync(`getfacl -p \"${filePath}\"`)\n        const lines = stdout.split('\\n')\n        const acls: { username: string, permissions: 'read' | 'write' }[] = []\n\n        for (const line of lines) {\n            // Regex to find \"user:username:rwx\" entries. \n            // Note: \"user::rwx\" is owner, \"user:bob:rwx\" is named user.\n            const match = line.match(/^user:([^:]+):([rwx-]+)/)\n            if (match) {\n                const username = match[1]\n                const permsStr = match[2]\n                // Filter out empty username if regex matches user:: (which it shouldnt due to + but safer to check)\n                if (username) {\n                    const permissions = permsStr.includes('w') ? 'write' : 'read'\n                    acls.push({ username, permissions })\n                }\n            }\n        }\n\n        // Mock for mac dev\n        if (acls.length === 0 && process.env.NODE_ENV === 'development' && os.platform() === 'darwin') {\n            return [\n                { username: 'esaghapo', permissions: 'read' },\n                { username: 'mcwyatt', permissions: 'write' }\n            ]\n        }\n\n        return acls\n    } catch (e) {\n        console.error(\"getfacl error:\", e)\n        return []\n    }\n}\n\nexport async function removeFileAccess(filePath: string, username: string): Promise<{ success: boolean, message: string }> {\n    try {\n        if (!isPathAllowed(filePath)) throw new Error(\"Access denied\")\n\n        await execAsync(`setfacl -x u:${username} \"${filePath}\"`)\n        return { success: true, message: `Removed access for ${username}` }\n    } catch (e: any) {\n        if (process.env.NODE_ENV === 'development' && os.platform() === 'darwin') {\n            return { success: true, message: `[DEV] Removed ACL for ${username}` }\n        }\n        return { success: false, message: e.message }\n    }\n}\n\nexport async function getFileShares(filePath: string): Promise<string[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n\n        // Scan all user directories in shared root\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n            const shares: string[] = []\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            if (target === filePath) {\n                                shares.push(userDir.name)\n                            }\n                        } catch (e) {\n                            // Not a symlink or other error, ignore\n                        }\n                    }\n                } catch (e) {\n                    // Cannot read user dir, ignore\n                }\n            }\n            return shares\n        } catch (e) {\n            // Shared root likely doesn't exist yet\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting shares:\", error)\n        return []\n    }\n}\n\nexport async function getSharedFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const currentUser = os.userInfo().username\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared', currentUser)\n\n        await fs.mkdir(sharedRoot, { recursive: true })\n\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(sharedRoot, relativePath)\n\n        // Security check\n        if (!fullPath.startsWith(sharedRoot)) {\n            throw new Error(\"Access denied: Cannot traverse above shared root\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n\n                // For shared files, we might want to know who shared it (the link owner usually)\n                // but lstat on the link itself in the parent dir might be needed if we want link info.\n                // For now, presenting the target file info is fine.\n\n                // Determine type extension logic same as getFiles\n                if (!entry.isDirectory()) {\n                    if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                    else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                    else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n                }\n\n                const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                return {\n                    id: entryPath,\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}`\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error getting shared files:\", error)\n        return []\n    }\n}\n\nexport async function getOutgoingShares(): Promise<SharedFileItem[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const myHome = os.homedir()\n\n        // Map of sourcePath -> { sharedWith: [] }\n        const shareMap = new Map<string, { username: string, linkPath: string }[]>()\n\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            // Check if target is inside my home directory (or belongs to me)\n                            // Ideally check if I own the target file\n                            if (target.startsWith(myHome)) {\n                                if (!shareMap.has(target)) {\n                                    shareMap.set(target, [])\n                                }\n                                shareMap.get(target)?.push({ username: userDir.name, linkPath })\n                            }\n                        } catch (e) {\n                            // Not a symlink\n                        }\n                    }\n                } catch (e) {\n                    // Ignore\n                }\n            }\n\n            // Convert map to SharedFileItem list\n            const results: SharedFileItem[] = []\n            for (const [filePath, shares] of shareMap.entries()) {\n                try {\n                    const stats = await fs.stat(filePath)\n                    const name = path.basename(filePath)\n\n                    let type: FileItem['type'] = 'file'\n                    if (stats.isDirectory()) type = 'folder'\n                    else if (name.endsWith('.sh') || name.endsWith('.py')) type = 'script'\n                    else if (name.endsWith('.csv') || name.endsWith('.json')) type = 'data'\n                    else if (name.endsWith('.zip') || name.endsWith('.tar') || name.endsWith('.gz')) type = 'archive'\n\n                    const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                    results.push({\n                        id: filePath,\n                        name: name,\n                        type: type,\n                        path: filePath,\n                        owner: await getUsername(stats.uid),\n                        group: String(stats.gid),\n                        modifiedAt: stats.mtime.toISOString(),\n                        sizeBytes: stats.size,\n                        permissions: `0${perms}`,\n                        sharedWith: shares.map(s => ({ username: s.username, permissions: 'read-only' }))\n                    })\n                } catch (e) {\n                    // File might have been deleted but link exists\n                }\n            }\n            return results\n\n        } catch (e) {\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting outgoing shares:\", error)\n        return []\n    }\n}\n\nexport async function unshareFile(targetUsername: string, fileName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const sharedLinkPath = path.join(os.homedir(), 'hpc_shared', targetUsername, fileName)\n        await fs.unlink(sharedLinkPath)\n        return { success: true, message: `Unshared ${fileName} with ${targetUsername}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to unshare\" }\n    }\n}\n\nexport async function changePermissions(filePath: string, mode: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.chmod(filePath, mode)\n        return { success: true, message: `Updated permissions for ${path.basename(filePath)}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to change permissions\" }\n    }\n}\n\nexport async function uploadFile(formData: FormData): Promise<{ success: boolean, message: string }> {\n    try {\n        const file = formData.get('file') as File\n        const currentPathSegments = JSON.parse(formData.get('pathSegments') as string)\n\n        if (!file) {\n            throw new Error(\"No file provided\")\n        }\n\n        const buffer = Buffer.from(await file.arrayBuffer())\n        const relativePath = path.join(...currentPathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.writeFile(path.join(targetDir, file.name), buffer)\n        return { success: true, message: `Uploaded ${file.name}` }\n    } catch (error: any) {\n        console.error(\"Upload error:\", error)\n        return { success: false, message: error.message || \"Upload failed\" }\n    }\n}\n\nexport async function createFolder(pathSegments: string[], folderName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const relativePath = path.join(...pathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath, folderName)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.mkdir(targetDir)\n        return { success: true, message: `Created folder ${folderName}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to create folder\" }\n    }\n}\n\nexport async function deleteItem(itemPath: string): Promise<{ success: boolean, message: string }> {\n    return moveToTrash(itemPath) // Default to trash\n}\n\nconst TRASH_PATH = path.join(os.homedir(), '.hpc_trash')\n\nexport async function moveToTrash(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n\n        const timestamp = Date.now()\n        const trashName = `${path.basename(itemPath)}_${timestamp}`\n        const trashPath = path.join(TRASH_PATH, trashName)\n\n        // Store metadata for restoration\n        const metadata = {\n            originalPath: itemPath,\n            deletedAt: new Date().toISOString()\n        }\n        await fs.writeFile(`${trashPath}.meta`, JSON.stringify(metadata))\n\n        await fs.rename(itemPath, trashPath)\n        return { success: true, message: `Moved to trash` }\n    } catch (error: any) {\n        console.error(\"Trash error:\", error)\n        return { success: false, message: error.message || \"Failed to move to trash\" }\n    }\n}\n\nexport async function getTrashFiles(): Promise<FileItem[]> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n        const entries = await fs.readdir(TRASH_PATH)\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            if (entry.endsWith('.meta')) return null\n\n            try {\n                const entryPath = path.join(TRASH_PATH, entry)\n                const stats = await fs.stat(entryPath)\n                const name = entry.split('_').slice(0, -1).join('_') || entry // Attempt to recover name\n\n                return {\n                    id: entryPath,\n                    name: name,\n                    type: stats.isDirectory() ? 'folder' : 'file',\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: '000' // Trash items usually treated differently\n                } as FileItem\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (e) {\n        return []\n    }\n}\n\nexport async function restoreFromTrash(trashPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        // Try to read metadata\n        const metaPath = `${trashPath}.meta`\n        let targetPath = path.join(os.homedir(), path.basename(trashPath).split('_').slice(0, -1).join('_'))\n\n        try {\n            const metaContent = await fs.readFile(metaPath, 'utf-8')\n            const metadata = JSON.parse(metaContent)\n            targetPath = metadata.originalPath\n        } catch (e) {\n            // Fallback used above\n        }\n\n        // Check if target exists\n        try {\n            await fs.access(targetPath)\n            return { success: false, message: \"Original location occupied. Rename or move file first.\" }\n        } catch (e) {\n            // Good, target doesn't exist\n        }\n\n        await fs.rename(trashPath, targetPath)\n        try { await fs.unlink(metaPath) } catch (e) { } // Delete meta if exists\n\n        return { success: true, message: \"Restored successfully\" }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to restore\" }\n    }\n}\n\nexport async function permanentDelete(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        if (!itemPath.startsWith(TRASH_PATH)) {\n            throw new Error(\"Access denied: Can only permanent delete from trash\")\n        }\n        await fs.rm(itemPath, { recursive: true, force: true })\n        try { await fs.unlink(`${itemPath}.meta`) } catch (e) { }\n        return { success: true, message: \"Permanently deleted\" }\n    } catch (error: any) {\n        return { success: false, message: error.message }\n    }\n}\n\nexport async function getRecentFiles(): Promise<FileItem[]> {\n    try {\n        // Optimization: Use system `find` command to avoid slow recursive Node.js calls / 502 timeouts\n        // maxdepth 4: Limit traversal depth\n        // -type f: Only files\n        // -mtime -7: Modified in last 7 days\n        // -not -path '*/.*': Exclude hidden files\n        // Exclude common heavy directories like node_modules, Library\n        const cmd = `find . -maxdepth 4 -not -path '*/.*' -not -path '*/node_modules/*' -not -path '*/Library/*' -mtime -7 -type f | head -n 50`\n\n        try {\n            const { stdout } = await execAsync(cmd, {\n                cwd: BASE_PATH,\n                timeout: 5000 // 5 second timeout protection\n            })\n\n            const relativePaths = stdout.trim().split('\\n').filter(p => p.length > 0)\n\n            const files = await Promise.all(relativePaths.map(async (relPath) => {\n                try {\n                    // find output is relative to CWD (BASE_PATH). e.g. \"./Documents/foo.txt\"\n                    const fullPath = path.join(BASE_PATH, relPath)\n                    const stats = await fs.stat(fullPath)\n                    const name = path.basename(fullPath)\n\n                    let type: FileItem['type'] = 'file'\n                    if (name.endsWith('.sh') || name.endsWith('.py')) type = 'script'\n                    else if (name.endsWith('.csv') || name.endsWith('.json')) type = 'data'\n                    else if (name.endsWith('.zip') || name.endsWith('.tar') || name.endsWith('.gz')) type = 'archive'\n\n                    return {\n                        id: fullPath,\n                        name: name,\n                        type: type,\n                        path: fullPath,\n                        owner: await getUsername(stats.uid),\n                        group: String(stats.gid),\n                        modifiedAt: stats.mtime.toISOString(),\n                        sizeBytes: stats.size,\n                        permissions: 'rw-r--r--'\n                    } as FileItem\n                } catch (e) {\n                    return null\n                }\n            }))\n\n            return files.filter((f): f is FileItem => f !== null)\n                .sort((a, b) => new Date(b.modifiedAt).getTime() - new Date(a.modifiedAt).getTime())\n        } catch (execError: any) {\n            console.error(\"Exec find error:\", execError)\n            return []\n        }\n    } catch (e) {\n        console.error(\"Recent files error:\", e)\n        return []\n    }\n}\n\nexport async function renameItem(currentPath: string, newName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const dir = path.dirname(currentPath)\n        const newPath = path.join(dir, newName)\n\n        // Security check\n        if (!newPath.startsWith(BASE_PATH)) throw new Error(\"Access denied\")\n\n        await fs.rename(currentPath, newPath)\n        return { success: true, message: `Renamed to ${newName}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to rename\" }\n    }\n}\n\n// Helper to validate paths\nfunction isPathAllowed(targetPath: string): boolean {\n    const resolvedPath = path.resolve(targetPath)\n    return ALLOWED_ROOTS.some(root => resolvedPath.startsWith(root)) ||\n        (resolvedPath !== '/' && !['/etc', '/var', '/usr', '/bin', '/sbin', '/proc', '/sys', '/boot'].some(restricted => resolvedPath.startsWith(restricted)))\n}\n\nexport async function moveItem(sourcePath: string, targetPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        // Security check\n        if (!isPathAllowed(sourcePath) || !isPathAllowed(targetPath)) {\n            throw new Error(\"Access denied: One or more paths are outside allowed directories\")\n        }\n\n        const fileName = path.basename(sourcePath)\n        const destPath = path.join(targetPath, fileName)\n\n        try {\n            await fs.rename(sourcePath, destPath)\n        } catch (e: any) {\n            // Handle Cross-Device Link error (EXDEV) by Copy + Delete\n            if (e.code === 'EXDEV') {\n                // Node 16.7+ supports fs.cp for recursive copy\n                await fs.cp(sourcePath, destPath, { recursive: true })\n                await fs.rm(sourcePath, { recursive: true, force: true })\n            } else {\n                throw e\n            }\n        }\n\n        return { success: true, message: `Moved to ${destPath}` }\n    } catch (error: any) {\n        console.error(\"Move error:\", error)\n        return { success: false, message: error.message || \"Failed to move\" }\n    }\n}\n\nconst FAVORITES_PATH = path.join(os.homedir(), '.hpc_favorites.json')\n\nexport async function toggleFavorite(itemPath: string): Promise<{ success: boolean, message: string, isFavorite: boolean }> {\n    try {\n        let favorites: string[] = []\n        try {\n            const data = await fs.readFile(FAVORITES_PATH, 'utf-8')\n            favorites = JSON.parse(data)\n        } catch (e) {\n            // No file yet\n        }\n\n        const idx = favorites.indexOf(itemPath)\n        let isFavorite = false\n        if (idx >= 0) {\n            favorites.splice(idx, 1) // Remove\n            isFavorite = false\n        } else {\n            favorites.push(itemPath) // Add\n            isFavorite = true\n        }\n\n        await fs.writeFile(FAVORITES_PATH, JSON.stringify(favorites))\n        return { success: true, message: isFavorite ? \"Added to favorites\" : \"Removed from favorites\", isFavorite }\n    } catch (error: any) {\n        return { success: false, message: \"Failed to update favorites\", isFavorite: false }\n    }\n}\n\nexport async function getFavorites(): Promise<FileItem[]> {\n    try {\n        let favoritesPaths: string[] = []\n        try {\n            const data = await fs.readFile(FAVORITES_PATH, 'utf-8')\n            favoritesPaths = JSON.parse(data)\n        } catch (e) {\n            return []\n        }\n\n        const files = await Promise.all(favoritesPaths.map(async (filePath) => {\n            try {\n                const stats = await fs.stat(filePath)\n                return {\n                    id: filePath,\n                    name: path.basename(filePath),\n                    type: stats.isDirectory() ? 'folder' : 'file',\n                    path: filePath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: 'rw-r--r--'\n                } as FileItem\n            } catch (e) {\n                return null // File might have been deleted\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (e) {\n        return []\n    }\n}\n\nexport async function searchUsers(query: string): Promise<{ username: string, uid?: string, gid?: string }[]> {\n    if (!query || query.length < 2) return []\n\n    try {\n        try {\n            const { stdout } = await execAsync(`getent passwd | grep -i \"${query}\" | head -n 20`)\n            if (stdout) {\n                return stdout.trim().split('\\n').map(line => {\n                    const parts = line.split(':')\n                    return {\n                        username: parts[0],\n                        uid: parts[2],\n                        gid: parts[3]\n                    }\n                })\n            }\n        } catch (e) {\n        }\n\n        try {\n            const { stdout } = await execAsync(`dscl . -list /Users | grep -i \"${query}\" | head -n 20`)\n            if (stdout) {\n                return stdout.trim().split('\\n').map(line => ({\n                    username: line.trim()\n                }))\n            }\n        } catch (e) {\n        }\n\n        return []\n    } catch (error) {\n        console.error(\"Search users error:\", error)\n        return []\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 975, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/.next-internal/server/app/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {getFiles as '4063d695a9e853e52488e4eae429ab5f3c0eb3e216'} from 'ACTIONS_MODULE0'\nexport {shareFile as '70c646fe7379a2a2d65c23cd27673dff057d09f365'} from 'ACTIONS_MODULE0'\nexport {getSharedFiles as '40099588628f710f4d9e22c199e98f338eb465781b'} from 'ACTIONS_MODULE0'\nexport {getOutgoingShares as '00f724b4ca412bcb595c35212354467d12f2529459'} from 'ACTIONS_MODULE0'\nexport {unshareFile as '60f535c6df1a1d9b470e0d25988d8759c27e1030c2'} from 'ACTIONS_MODULE0'\nexport {changePermissions as '60e19c8c998f07a6ca71d9eb820622f55035e0d360'} from 'ACTIONS_MODULE0'\nexport {uploadFile as '4082fd6d6c6f40bf76de86e0df85c7a7e0c9fa9f91'} from 'ACTIONS_MODULE0'\nexport {createFolder as '609ff9fef701996ebb30337f0573aa84a15e364c28'} from 'ACTIONS_MODULE0'\nexport {deleteItem as '4085ad2e2fe1bf148e66865890f87db6e185f5411a'} from 'ACTIONS_MODULE0'\nexport {getTrashFiles as '0020d9d54704edd74264ab2de83e04253236b91dab'} from 'ACTIONS_MODULE0'\nexport {permanentDelete as '40983b261685df111a29469abdca7b2d96a175a6e5'} from 'ACTIONS_MODULE0'\nexport {restoreFromTrash as '40e2810abb4df32d98f4fe01b4a2c23c5578905f69'} from 'ACTIONS_MODULE0'\nexport {getRecentFiles as '003e338349fc9faaffdb7fe8784c42cb98899ec388'} from 'ACTIONS_MODULE0'\nexport {renameItem as '604d4be896ae4ef055605db17161a7003806ef5633'} from 'ACTIONS_MODULE0'\nexport {moveItem as '60484b10479f56499b8d2807bd2ec3adfa3701149b'} from 'ACTIONS_MODULE0'\nexport {toggleFavorite as '400bd08efdc740ce9ea47f88e1cd6d94740f49bb3a'} from 'ACTIONS_MODULE0'\nexport {getFavorites as '007b570a57785f01535b5d375be38cb258aa44d016'} from 'ACTIONS_MODULE0'\nexport {getDataPath as '00c89052df53b78dcb1d808ba92feca4271fe45d8e'} from 'ACTIONS_MODULE0'\nexport {getFileShares as '40d16576a1197cb79f87d426537e25047357caad19'} from 'ACTIONS_MODULE0'\nexport {getFileAcls as '405b43a83ec49cfc8833ff9ccc7168ddaf28b37aee'} from 'ACTIONS_MODULE0'\nexport {removeFileAccess as '6047e3679e96dac23760dad3649b0526b947378009'} from 'ACTIONS_MODULE0'\nexport {searchUsers as '40c1481f0c0aea852a62ccf66004dcd7fd9ef6f7a9'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA"}},
    {"offset": {"line": 1055, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/node_modules/next/src/build/webpack/loaders/next-flight-loader/server-reference.ts"],"sourcesContent":["/* eslint-disable import/no-extraneous-dependencies */\nexport { registerServerReference } from 'react-server-dom-webpack/server'\n"],"names":["registerServerReference"],"mappings":"AAAA,oDAAoD;;;+BAC3CA,2BAAAA;;;eAAAA,QAAAA,uBAAuB;;;wBAAQ","ignoreList":[0]}},
    {"offset": {"line": 1069, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/node_modules/next/src/build/webpack/loaders/next-flight-loader/action-validate.ts"],"sourcesContent":["// This function ensures that all the exported values are valid server actions,\n// during the runtime. By definition all actions are required to be async\n// functions, but here we can only check that they are functions.\nexport function ensureServerEntryExports(actions: any[]) {\n  for (let i = 0; i < actions.length; i++) {\n    const action = actions[i]\n    if (typeof action !== 'function') {\n      throw new Error(\n        `A \"use server\" file can only export async functions, found ${typeof action}.\\nRead more: https://nextjs.org/docs/messages/invalid-use-server-value`\n      )\n    }\n  }\n}\n"],"names":["ensureServerEntryExports","actions","i","length","action","Error"],"mappings":"AAAA,+EAA+E;AAC/E,yEAAyE;AACzE,iEAAiE;;;;+BACjDA,4BAAAA;;;eAAAA;;;AAAT,SAASA,yBAAyBC,OAAc;IACrD,IAAK,IAAIC,IAAI,GAAGA,IAAID,QAAQE,MAAM,EAAED,IAAK;QACvC,MAAME,SAASH,OAAO,CAACC,EAAE;QACzB,IAAI,OAAOE,WAAW,YAAY;YAChC,MAAM,OAAA,cAEL,CAFK,IAAIC,MACR,CAAC,2DAA2D,EAAE,OAAOD,OAAO,uEAAuE,CAAC,GADhJ,qBAAA;uBAAA;4BAAA;8BAAA;YAEN;QACF;IACF;AACF","ignoreList":[0]}}]
}