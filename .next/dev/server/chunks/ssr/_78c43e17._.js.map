{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from 'clsx'\nimport { twMerge } from 'tailwind-merge'\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,IAAA,sKAAO,EAAC,IAAA,6IAAI,EAAC;AACtB"}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/components/ui/button.tsx"],"sourcesContent":["import * as React from 'react'\nimport { Slot } from '@radix-ui/react-slot'\nimport { cva, type VariantProps } from 'class-variance-authority'\n\nimport { cn } from '@/lib/utils'\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\n  {\n    variants: {\n      variant: {\n        default: 'bg-primary text-primary-foreground hover:bg-primary/90',\n        destructive:\n          'bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60',\n        outline:\n          'border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50',\n        secondary:\n          'bg-secondary text-secondary-foreground hover:bg-secondary/80',\n        ghost:\n          'hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50',\n        link: 'text-primary underline-offset-4 hover:underline',\n      },\n      size: {\n        default: 'h-9 px-4 py-2 has-[>svg]:px-3',\n        sm: 'h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5',\n        lg: 'h-10 rounded-md px-6 has-[>svg]:px-4',\n        icon: 'size-9',\n        'icon-sm': 'size-8',\n        'icon-lg': 'size-10',\n      },\n    },\n    defaultVariants: {\n      variant: 'default',\n      size: 'default',\n    },\n  },\n)\n\nfunction Button({\n  className,\n  variant,\n  size,\n  asChild = false,\n  ...props\n}: React.ComponentProps<'button'> &\n  VariantProps<typeof buttonVariants> & {\n    asChild?: boolean\n  }) {\n  const Comp = asChild ? Slot : 'button'\n\n  return (\n    <Comp\n      data-slot=\"button\"\n      className={cn(buttonVariants({ variant, size, className }))}\n      {...props}\n    />\n  )\n}\n\nexport { Button, buttonVariants }\n"],"names":[],"mappings":";;;;;;;AACA;AACA;AAEA;;;;;AAEA,MAAM,iBAAiB,IAAA,uKAAG,EACxB,+bACA;IACE,UAAU;QACR,SAAS;YACP,SAAS;YACT,aACE;YACF,SACE;YACF,WACE;YACF,OACE;YACF,MAAM;QACR;QACA,MAAM;YACJ,SAAS;YACT,IAAI;YACJ,IAAI;YACJ,MAAM;YACN,WAAW;YACX,WAAW;QACb;IACF;IACA,iBAAiB;QACf,SAAS;QACT,MAAM;IACR;AACF;AAGF,SAAS,OAAO,EACd,SAAS,EACT,OAAO,EACP,IAAI,EACJ,UAAU,KAAK,EACf,GAAG,OAIF;IACD,MAAM,OAAO,UAAU,wKAAI,GAAG;IAE9B,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kHAAE,EAAC,eAAe;YAAE;YAAS;YAAM;QAAU;QACvD,GAAG,KAAK;;;;;;AAGf"}},
    {"offset": {"line": 78, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/components/ui/dropdown-menu.tsx"],"sourcesContent":["'use client'\n\nimport * as React from 'react'\nimport * as DropdownMenuPrimitive from '@radix-ui/react-dropdown-menu'\nimport { CheckIcon, ChevronRightIcon, CircleIcon } from 'lucide-react'\n\nimport { cn } from '@/lib/utils'\n\nfunction DropdownMenu({\n  ...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {\n  return <DropdownMenuPrimitive.Root data-slot=\"dropdown-menu\" {...props} />\n}\n\nfunction DropdownMenuPortal({\n  ...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {\n  return (\n    <DropdownMenuPrimitive.Portal data-slot=\"dropdown-menu-portal\" {...props} />\n  )\n}\n\nfunction DropdownMenuTrigger({\n  ...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {\n  return (\n    <DropdownMenuPrimitive.Trigger\n      data-slot=\"dropdown-menu-trigger\"\n      {...props}\n    />\n  )\n}\n\nfunction DropdownMenuContent({\n  className,\n  sideOffset = 4,\n  ...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {\n  return (\n    <DropdownMenuPrimitive.Portal>\n      <DropdownMenuPrimitive.Content\n        data-slot=\"dropdown-menu-content\"\n        sideOffset={sideOffset}\n        className={cn(\n          'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md',\n          className,\n        )}\n        {...props}\n      />\n    </DropdownMenuPrimitive.Portal>\n  )\n}\n\nfunction DropdownMenuGroup({\n  ...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {\n  return (\n    <DropdownMenuPrimitive.Group data-slot=\"dropdown-menu-group\" {...props} />\n  )\n}\n\nfunction DropdownMenuItem({\n  className,\n  inset,\n  variant = 'default',\n  ...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {\n  inset?: boolean\n  variant?: 'default' | 'destructive'\n}) {\n  return (\n    <DropdownMenuPrimitive.Item\n      data-slot=\"dropdown-menu-item\"\n      data-inset={inset}\n      data-variant={variant}\n      className={cn(\n        \"focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\",\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction DropdownMenuCheckboxItem({\n  className,\n  children,\n  checked,\n  ...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {\n  return (\n    <DropdownMenuPrimitive.CheckboxItem\n      data-slot=\"dropdown-menu-checkbox-item\"\n      className={cn(\n        \"focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\",\n        className,\n      )}\n      checked={checked}\n      {...props}\n    >\n      <span className=\"pointer-events-none absolute left-2 flex size-3.5 items-center justify-center\">\n        <DropdownMenuPrimitive.ItemIndicator>\n          <CheckIcon className=\"size-4\" />\n        </DropdownMenuPrimitive.ItemIndicator>\n      </span>\n      {children}\n    </DropdownMenuPrimitive.CheckboxItem>\n  )\n}\n\nfunction DropdownMenuRadioGroup({\n  ...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {\n  return (\n    <DropdownMenuPrimitive.RadioGroup\n      data-slot=\"dropdown-menu-radio-group\"\n      {...props}\n    />\n  )\n}\n\nfunction DropdownMenuRadioItem({\n  className,\n  children,\n  ...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {\n  return (\n    <DropdownMenuPrimitive.RadioItem\n      data-slot=\"dropdown-menu-radio-item\"\n      className={cn(\n        \"focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\",\n        className,\n      )}\n      {...props}\n    >\n      <span className=\"pointer-events-none absolute left-2 flex size-3.5 items-center justify-center\">\n        <DropdownMenuPrimitive.ItemIndicator>\n          <CircleIcon className=\"size-2 fill-current\" />\n        </DropdownMenuPrimitive.ItemIndicator>\n      </span>\n      {children}\n    </DropdownMenuPrimitive.RadioItem>\n  )\n}\n\nfunction DropdownMenuLabel({\n  className,\n  inset,\n  ...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {\n  inset?: boolean\n}) {\n  return (\n    <DropdownMenuPrimitive.Label\n      data-slot=\"dropdown-menu-label\"\n      data-inset={inset}\n      className={cn(\n        'px-2 py-1.5 text-sm font-medium data-[inset]:pl-8',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction DropdownMenuSeparator({\n  className,\n  ...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {\n  return (\n    <DropdownMenuPrimitive.Separator\n      data-slot=\"dropdown-menu-separator\"\n      className={cn('bg-border -mx-1 my-1 h-px', className)}\n      {...props}\n    />\n  )\n}\n\nfunction DropdownMenuShortcut({\n  className,\n  ...props\n}: React.ComponentProps<'span'>) {\n  return (\n    <span\n      data-slot=\"dropdown-menu-shortcut\"\n      className={cn(\n        'text-muted-foreground ml-auto text-xs tracking-widest',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction DropdownMenuSub({\n  ...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {\n  return <DropdownMenuPrimitive.Sub data-slot=\"dropdown-menu-sub\" {...props} />\n}\n\nfunction DropdownMenuSubTrigger({\n  className,\n  inset,\n  children,\n  ...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {\n  inset?: boolean\n}) {\n  return (\n    <DropdownMenuPrimitive.SubTrigger\n      data-slot=\"dropdown-menu-sub-trigger\"\n      data-inset={inset}\n      className={cn(\n        \"focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\",\n        className,\n      )}\n      {...props}\n    >\n      {children}\n      <ChevronRightIcon className=\"ml-auto size-4\" />\n    </DropdownMenuPrimitive.SubTrigger>\n  )\n}\n\nfunction DropdownMenuSubContent({\n  className,\n  ...props\n}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {\n  return (\n    <DropdownMenuPrimitive.SubContent\n      data-slot=\"dropdown-menu-sub-content\"\n      className={cn(\n        'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nexport {\n  DropdownMenu,\n  DropdownMenuPortal,\n  DropdownMenuTrigger,\n  DropdownMenuContent,\n  DropdownMenuGroup,\n  DropdownMenuLabel,\n  DropdownMenuItem,\n  DropdownMenuCheckboxItem,\n  DropdownMenuRadioGroup,\n  DropdownMenuRadioItem,\n  DropdownMenuSeparator,\n  DropdownMenuShortcut,\n  DropdownMenuSub,\n  DropdownMenuSubTrigger,\n  DropdownMenuSubContent,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;AACA;AAAA;AAAA;AAEA;AANA;;;;;AAQA,SAAS,aAAa,EACpB,GAAG,OACqD;IACxD,qBAAO,8OAAC,oLAA0B;QAAC,aAAU;QAAiB,GAAG,KAAK;;;;;;AACxE;AAEA,SAAS,mBAAmB,EAC1B,GAAG,OACuD;IAC1D,qBACE,8OAAC,sLAA4B;QAAC,aAAU;QAAwB,GAAG,KAAK;;;;;;AAE5E;AAEA,SAAS,oBAAoB,EAC3B,GAAG,OACwD;IAC3D,qBACE,8OAAC,uLAA6B;QAC5B,aAAU;QACT,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,oBAAoB,EAC3B,SAAS,EACT,aAAa,CAAC,EACd,GAAG,OACwD;IAC3D,qBACE,8OAAC,sLAA4B;kBAC3B,cAAA,8OAAC,uLAA6B;YAC5B,aAAU;YACV,YAAY;YACZ,WAAW,IAAA,kHAAE,EACX,0jBACA;YAED,GAAG,KAAK;;;;;;;;;;;AAIjB;AAEA,SAAS,kBAAkB,EACzB,GAAG,OACsD;IACzD,qBACE,8OAAC,qLAA2B;QAAC,aAAU;QAAuB,GAAG,KAAK;;;;;;AAE1E;AAEA,SAAS,iBAAiB,EACxB,SAAS,EACT,KAAK,EACL,UAAU,SAAS,EACnB,GAAG,OAIJ;IACC,qBACE,8OAAC,oLAA0B;QACzB,aAAU;QACV,cAAY;QACZ,gBAAc;QACd,WAAW,IAAA,kHAAE,EACX,+mBACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,yBAAyB,EAChC,SAAS,EACT,QAAQ,EACR,OAAO,EACP,GAAG,OAC6D;IAChE,qBACE,8OAAC,4LAAkC;QACjC,aAAU;QACV,WAAW,IAAA,kHAAE,EACX,gTACA;QAEF,SAAS;QACR,GAAG,KAAK;;0BAET,8OAAC;gBAAK,WAAU;0BACd,cAAA,8OAAC,6LAAmC;8BAClC,cAAA,8OAAC,qNAAS;wBAAC,WAAU;;;;;;;;;;;;;;;;YAGxB;;;;;;;AAGP;AAEA,SAAS,uBAAuB,EAC9B,GAAG,OAC2D;IAC9D,qBACE,8OAAC,0LAAgC;QAC/B,aAAU;QACT,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,sBAAsB,EAC7B,SAAS,EACT,QAAQ,EACR,GAAG,OAC0D;IAC7D,qBACE,8OAAC,yLAA+B;QAC9B,aAAU;QACV,WAAW,IAAA,kHAAE,EACX,gTACA;QAED,GAAG,KAAK;;0BAET,8OAAC;gBAAK,WAAU;0BACd,cAAA,8OAAC,6LAAmC;8BAClC,cAAA,8OAAC,wNAAU;wBAAC,WAAU;;;;;;;;;;;;;;;;YAGzB;;;;;;;AAGP;AAEA,SAAS,kBAAkB,EACzB,SAAS,EACT,KAAK,EACL,GAAG,OAGJ;IACC,qBACE,8OAAC,qLAA2B;QAC1B,aAAU;QACV,cAAY;QACZ,WAAW,IAAA,kHAAE,EACX,qDACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,sBAAsB,EAC7B,SAAS,EACT,GAAG,OAC0D;IAC7D,qBACE,8OAAC,yLAA+B;QAC9B,aAAU;QACV,WAAW,IAAA,kHAAE,EAAC,6BAA6B;QAC1C,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,qBAAqB,EAC5B,SAAS,EACT,GAAG,OAC0B;IAC7B,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kHAAE,EACX,yDACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,gBAAgB,EACvB,GAAG,OACoD;IACvD,qBAAO,8OAAC,mLAAyB;QAAC,aAAU;QAAqB,GAAG,KAAK;;;;;;AAC3E;AAEA,SAAS,uBAAuB,EAC9B,SAAS,EACT,KAAK,EACL,QAAQ,EACR,GAAG,OAGJ;IACC,qBACE,8OAAC,0LAAgC;QAC/B,aAAU;QACV,cAAY;QACZ,WAAW,IAAA,kHAAE,EACX,8WACA;QAED,GAAG,KAAK;;YAER;0BACD,8OAAC,8OAAgB;gBAAC,WAAU;;;;;;;;;;;;AAGlC;AAEA,SAAS,uBAAuB,EAC9B,SAAS,EACT,GAAG,OAC2D;IAC9D,qBACE,8OAAC,0LAAgC;QAC/B,aAAU;QACV,WAAW,IAAA,kHAAE,EACX,ifACA;QAED,GAAG,KAAK;;;;;;AAGf"}},
    {"offset": {"line": 353, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/components/Sidebar.tsx"],"sourcesContent":["\n\"use client\"\n\nimport { Button } from \"@/components/ui/button\"\nimport {\n    DropdownMenu,\n    DropdownMenuContent,\n    DropdownMenuItem,\n    DropdownMenuTrigger,\n    DropdownMenuSeparator,\n} from \"@/components/ui/dropdown-menu\"\nimport {\n    Home,\n    Users,\n    Clock,\n    Star,\n    Trash2,\n    Plus,\n    FolderPlus,\n    FilePlus,\n    Upload,\n} from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\n\ninterface SidebarProps extends React.HTMLAttributes<HTMLDivElement> {\n    currentCategory: string\n    onCategoryChange: (category: string) => void\n    onNewItem: (type: 'folder' | 'file' | 'script' | 'upload') => void\n}\n\nexport function Sidebar({ className, currentCategory, onCategoryChange, onNewItem }: SidebarProps) {\n    const navItems = [\n        { name: \"Home\", icon: Home, id: \"home\" },\n        { name: \"Shared Projects\", icon: Users, id: \"shared\" },\n        { name: \"Recent Files\", icon: Clock, id: \"recent\" },\n        { name: \"Favorites\", icon: Star, id: \"favorites\" },\n        { name: \"Trash / Archive\", icon: Trash2, id: \"trash\" },\n    ]\n\n    return (\n        <div className={cn(\"pb-12 w-64 border-r min-h-screen bg-card\", className)}>\n            <div className=\"space-y-4 py-4\">\n                <div className=\"px-3 py-2\">\n                    <div className=\"mb-6 px-4\">\n                        <h2 className=\"text-xl font-bold tracking-tight mb-4\">HPC Explorer</h2>\n                        <DropdownMenu>\n                            <DropdownMenuTrigger asChild>\n                                <Button className=\"w-full justify-start gap-2 shadow-md\" size=\"lg\">\n                                    <Plus className=\"h-5 w-5\" />\n                                    New\n                                </Button>\n                            </DropdownMenuTrigger>\n                            <DropdownMenuContent className=\"w-56\" align=\"start\">\n                                <DropdownMenuItem onClick={() => onNewItem('folder')}>\n                                    <FolderPlus className=\"mr-2 h-4 w-4\" />\n                                    <span>New Folder</span>\n                                </DropdownMenuItem>\n                                <DropdownMenuSeparator />\n                                <DropdownMenuItem onClick={() => onNewItem('upload')}>\n                                    <Upload className=\"mr-2 h-4 w-4\" />\n                                    <span>File Upload</span>\n                                </DropdownMenuItem>\n                                <DropdownMenuItem onClick={() => onNewItem('upload')}>\n                                    <Upload className=\"mr-2 h-4 w-4\" />\n                                    <span>Folder Upload</span>\n                                </DropdownMenuItem>\n                                <DropdownMenuSeparator />\n                                <DropdownMenuItem onClick={() => onNewItem('script')}>\n                                    <FilePlus className=\"mr-2 h-4 w-4\" />\n                                    <span>New Script (.sh)</span>\n                                </DropdownMenuItem>\n                                <DropdownMenuItem onClick={() => onNewItem('script')}>\n                                    <FilePlus className=\"mr-2 h-4 w-4\" />\n                                    <span>New Script (.py)</span>\n                                </DropdownMenuItem>\n                            </DropdownMenuContent>\n                        </DropdownMenu>\n                    </div>\n\n                    <div className=\"space-y-1\">\n                        {navItems.map((item) => (\n                            <Button\n                                key={item.id}\n                                variant={currentCategory === item.id ? \"secondary\" : \"ghost\"}\n                                className={cn(\n                                    \"w-full justify-start\",\n                                    currentCategory === item.id && \"font-semibold\"\n                                )}\n                                onClick={() => onCategoryChange(item.id)}\n                            >\n                                <item.icon className=\"mr-2 h-4 w-4\" />\n                                {item.name}\n                            </Button>\n                        ))}\n                    </div>\n                </div>\n            </div>\n        </div>\n    )\n}\n"],"names":[],"mappings":";;;;;AAGA;AACA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AArBA;;;;;;AA6BO,SAAS,QAAQ,EAAE,SAAS,EAAE,eAAe,EAAE,gBAAgB,EAAE,SAAS,EAAgB;IAC7F,MAAM,WAAW;QACb;YAAE,MAAM;YAAQ,MAAM,2MAAI;YAAE,IAAI;QAAO;QACvC;YAAE,MAAM;YAAmB,MAAM,6MAAK;YAAE,IAAI;QAAS;QACrD;YAAE,MAAM;YAAgB,MAAM,6MAAK;YAAE,IAAI;QAAS;QAClD;YAAE,MAAM;YAAa,MAAM,0MAAI;YAAE,IAAI;QAAY;QACjD;YAAE,MAAM;YAAmB,MAAM,oNAAM;YAAE,IAAI;QAAQ;KACxD;IAED,qBACI,8OAAC;QAAI,WAAW,IAAA,kHAAE,EAAC,4CAA4C;kBAC3D,cAAA,8OAAC;YAAI,WAAU;sBACX,cAAA,8OAAC;gBAAI,WAAU;;kCACX,8OAAC;wBAAI,WAAU;;0CACX,8OAAC;gCAAG,WAAU;0CAAwC;;;;;;0CACtD,8OAAC,qJAAY;;kDACT,8OAAC,4JAAmB;wCAAC,OAAO;kDACxB,cAAA,8OAAC,qIAAM;4CAAC,WAAU;4CAAuC,MAAK;;8DAC1D,8OAAC,0MAAI;oDAAC,WAAU;;;;;;gDAAY;;;;;;;;;;;;kDAIpC,8OAAC,4JAAmB;wCAAC,WAAU;wCAAO,OAAM;;0DACxC,8OAAC,yJAAgB;gDAAC,SAAS,IAAM,UAAU;;kEACvC,8OAAC,gOAAU;wDAAC,WAAU;;;;;;kEACtB,8OAAC;kEAAK;;;;;;;;;;;;0DAEV,8OAAC,8JAAqB;;;;;0DACtB,8OAAC,yJAAgB;gDAAC,SAAS,IAAM,UAAU;;kEACvC,8OAAC,gNAAM;wDAAC,WAAU;;;;;;kEAClB,8OAAC;kEAAK;;;;;;;;;;;;0DAEV,8OAAC,yJAAgB;gDAAC,SAAS,IAAM,UAAU;;kEACvC,8OAAC,gNAAM;wDAAC,WAAU;;;;;;kEAClB,8OAAC;kEAAK;;;;;;;;;;;;0DAEV,8OAAC,8JAAqB;;;;;0DACtB,8OAAC,yJAAgB;gDAAC,SAAS,IAAM,UAAU;;kEACvC,8OAAC,0NAAQ;wDAAC,WAAU;;;;;;kEACpB,8OAAC;kEAAK;;;;;;;;;;;;0DAEV,8OAAC,yJAAgB;gDAAC,SAAS,IAAM,UAAU;;kEACvC,8OAAC,0NAAQ;wDAAC,WAAU;;;;;;kEACpB,8OAAC;kEAAK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAMtB,8OAAC;wBAAI,WAAU;kCACV,SAAS,GAAG,CAAC,CAAC,qBACX,8OAAC,qIAAM;gCAEH,SAAS,oBAAoB,KAAK,EAAE,GAAG,cAAc;gCACrD,WAAW,IAAA,kHAAE,EACT,wBACA,oBAAoB,KAAK,EAAE,IAAI;gCAEnC,SAAS,IAAM,iBAAiB,KAAK,EAAE;;kDAEvC,8OAAC,KAAK,IAAI;wCAAC,WAAU;;;;;;oCACpB,KAAK,IAAI;;+BATL,KAAK,EAAE;;;;;;;;;;;;;;;;;;;;;;;;;;AAiB5C"}},
    {"offset": {"line": 643, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/components/ui/table.tsx"],"sourcesContent":["'use client'\n\nimport * as React from 'react'\n\nimport { cn } from '@/lib/utils'\n\nfunction Table({ className, ...props }: React.ComponentProps<'table'>) {\n  return (\n    <div\n      data-slot=\"table-container\"\n      className=\"relative w-full overflow-x-auto\"\n    >\n      <table\n        data-slot=\"table\"\n        className={cn('w-full caption-bottom text-sm', className)}\n        {...props}\n      />\n    </div>\n  )\n}\n\nfunction TableHeader({ className, ...props }: React.ComponentProps<'thead'>) {\n  return (\n    <thead\n      data-slot=\"table-header\"\n      className={cn('[&_tr]:border-b', className)}\n      {...props}\n    />\n  )\n}\n\nfunction TableBody({ className, ...props }: React.ComponentProps<'tbody'>) {\n  return (\n    <tbody\n      data-slot=\"table-body\"\n      className={cn('[&_tr:last-child]:border-0', className)}\n      {...props}\n    />\n  )\n}\n\nfunction TableFooter({ className, ...props }: React.ComponentProps<'tfoot'>) {\n  return (\n    <tfoot\n      data-slot=\"table-footer\"\n      className={cn(\n        'bg-muted/50 border-t font-medium [&>tr]:last:border-b-0',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction TableRow({ className, ...props }: React.ComponentProps<'tr'>) {\n  return (\n    <tr\n      data-slot=\"table-row\"\n      className={cn(\n        'hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction TableHead({ className, ...props }: React.ComponentProps<'th'>) {\n  return (\n    <th\n      data-slot=\"table-head\"\n      className={cn(\n        'text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction TableCell({ className, ...props }: React.ComponentProps<'td'>) {\n  return (\n    <td\n      data-slot=\"table-cell\"\n      className={cn(\n        'p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction TableCaption({\n  className,\n  ...props\n}: React.ComponentProps<'caption'>) {\n  return (\n    <caption\n      data-slot=\"table-caption\"\n      className={cn('text-muted-foreground mt-4 text-sm', className)}\n      {...props}\n    />\n  )\n}\n\nexport {\n  Table,\n  TableHeader,\n  TableBody,\n  TableFooter,\n  TableHead,\n  TableRow,\n  TableCell,\n  TableCaption,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAIA;AAJA;;;AAMA,SAAS,MAAM,EAAE,SAAS,EAAE,GAAG,OAAsC;IACnE,qBACE,8OAAC;QACC,aAAU;QACV,WAAU;kBAEV,cAAA,8OAAC;YACC,aAAU;YACV,WAAW,IAAA,kHAAE,EAAC,iCAAiC;YAC9C,GAAG,KAAK;;;;;;;;;;;AAIjB;AAEA,SAAS,YAAY,EAAE,SAAS,EAAE,GAAG,OAAsC;IACzE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kHAAE,EAAC,mBAAmB;QAChC,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,UAAU,EAAE,SAAS,EAAE,GAAG,OAAsC;IACvE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kHAAE,EAAC,8BAA8B;QAC3C,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,YAAY,EAAE,SAAS,EAAE,GAAG,OAAsC;IACzE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kHAAE,EACX,2DACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,SAAS,EAAE,SAAS,EAAE,GAAG,OAAmC;IACnE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kHAAE,EACX,+EACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,UAAU,EAAE,SAAS,EAAE,GAAG,OAAmC;IACpE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kHAAE,EACX,sJACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,UAAU,EAAE,SAAS,EAAE,GAAG,OAAmC;IACpE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kHAAE,EACX,0GACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,aAAa,EACpB,SAAS,EACT,GAAG,OAC6B;IAChC,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kHAAE,EAAC,sCAAsC;QACnD,GAAG,KAAK;;;;;;AAGf"}},
    {"offset": {"line": 767, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/components/FileList.tsx"],"sourcesContent":["\n\"use client\"\n\nimport { FileItem } from \"@/lib/mockData\"\nimport {\n    Table,\n    TableBody,\n    TableCell,\n    TableHead,\n    TableHeader,\n    TableRow,\n} from \"@/components/ui/table\"\nimport {\n    DropdownMenu,\n    DropdownMenuContent,\n    DropdownMenuItem,\n    DropdownMenuSeparator,\n    DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\"\nimport { Button } from \"@/components/ui/button\"\nimport {\n    MoreVertical,\n    Folder,\n    FileText,\n    FileCode,\n    Database,\n    Archive,\n    Download,\n    Pencil,\n    Move,\n    Trash2,\n\n    Copy,\n    Shield,\n    Share2\n} from \"lucide-react\"\nimport { cn } from \"@/lib/utils\"\nimport { toast } from \"sonner\"\n\ninterface FileListProps {\n    files: FileItem[]\n    onFileSelect: (file: FileItem) => void\n    onFolderNavigate: (folderId: string) => void\n    onSort: (column: string) => void\n    sortConfig: { column: string, direction: 'asc' | 'desc' }\n    viewMode: 'list' | 'grid'\n    onRename: (id: string) => void\n    onDelete: (id: string) => void\n    onCopyPath: (file: FileItem) => void\n    onDownload: (file: FileItem) => void\n    onShare: (file: FileItem) => void\n}\n\nexport function FileList({\n    files,\n    onFileSelect,\n    onFolderNavigate,\n    onSort,\n    sortConfig,\n    viewMode,\n    onRename,\n    onDelete,\n    onCopyPath,\n    onDownload,\n    onShare\n}: FileListProps) {\n\n    const getIcon = (type: FileItem['type']) => {\n        switch (type) {\n            case 'folder': return <Folder className=\"h-6 w-6 text-blue-500 fill-blue-500/20\" />\n            case 'script': return <FileCode className=\"h-6 w-6 text-green-500\" />\n            case 'data': return <Database className=\"h-6 w-6 text-yellow-500\" />\n            case 'archive': return <Archive className=\"h-6 w-6 text-orange-500\" />\n            default: return <FileText className=\"h-6 w-6 text-gray-500\" />\n        }\n    }\n\n    const formatSize = (bytes: number) => {\n        if (bytes === 0) return \"-\"\n        const k = 1024\n        const sizes = ['B', 'KB', 'MB', 'GB', 'TB']\n        const i = Math.floor(Math.log(bytes) / Math.log(k))\n        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i]\n    }\n\n    // Double click logic wrapper to prevent single click firing on double click if needed,\n    // but for now simple separation is fine. List vs Grid handled below.\n\n    if (viewMode === 'grid') {\n        return (\n            <div className=\"grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4\">\n                {files.map((file) => (\n                    <div\n                        key={file.id}\n                        className=\"group relative flex flex-col items-center p-4 border rounded-xl hover:bg-muted/50 cursor-pointer transition-colors\"\n                        onClick={() => onFileSelect(file)}\n                        onDoubleClick={(e) => {\n                            e.stopPropagation()\n                            if (file.type === 'folder') onFolderNavigate(file.id)\n                        }}\n                    >\n                        <div\n                            className=\"mb-3 p-3 bg-muted/30 rounded-full group-hover:bg-background transition-colors\"\n                            onClick={(e) => {\n                                if (file.type === 'folder') {\n                                    e.stopPropagation()\n                                    onFolderNavigate(file.id)\n                                }\n                            }}\n                        >\n                            {getIcon(file.type)}\n                        </div>\n                        <span className=\"text-sm font-medium text-center truncate w-full px-2\" title={file.name}>\n                            {file.name}\n                        </span>\n                        <span className=\"text-xs text-muted-foreground mt-1\">\n                            {formatSize(file.sizeBytes)}\n                        </span>\n\n                        <div className=\"absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity\">\n                            <DropdownMenu>\n                                <DropdownMenuTrigger asChild>\n                                    <Button variant=\"ghost\" className=\"h-6 w-6 p-0\">\n                                        <MoreVertical className=\"h-3 w-3\" />\n                                    </Button>\n                                </DropdownMenuTrigger>\n                                <DropdownMenuContent align=\"end\">\n                                    <DropdownMenuItem onClick={() => onShare(file)}>\n                                        <Share2 className=\"mr-2 h-4 w-4\" /> Share\n                                    </DropdownMenuItem>\n                                    <DropdownMenuItem onClick={() => onDownload(file)}>\n                                        <Download className=\"mr-2 h-4 w-4\" /> Download\n                                    </DropdownMenuItem>\n                                    <DropdownMenuItem onClick={() => onRename(file.id)}>\n                                        <Pencil className=\"mr-2 h-4 w-4\" /> Rename\n                                    </DropdownMenuItem>\n                                    <DropdownMenuItem>\n                                        <Move className=\"mr-2 h-4 w-4\" /> Move\n                                    </DropdownMenuItem>\n                                    <DropdownMenuItem onClick={() => onCopyPath(file)}>\n                                        <Copy className=\"mr-2 h-4 w-4\" /> Copy Path\n                                    </DropdownMenuItem>\n                                    <DropdownMenuSeparator />\n                                    <DropdownMenuItem onClick={() => toast(\"Permissions\", { description: file.permissions })}>\n                                        <Shield className=\"mr-2 h-4 w-4\" /> Permissions\n                                    </DropdownMenuItem>\n                                    <DropdownMenuSeparator />\n                                    <DropdownMenuItem className=\"text-red-600\" onClick={() => onDelete(file.id)}>\n                                        <Trash2 className=\"mr-2 h-4 w-4\" /> Delete\n                                    </DropdownMenuItem>\n                                </DropdownMenuContent>\n                            </DropdownMenu>\n                        </div>\n                    </div>\n                ))}\n            </div>\n        )\n    }\n\n    return (\n        <div className=\"rounded-md border\">\n            <Table>\n                <TableHeader>\n                    <TableRow>\n                        <TableHead className=\"w-[40%] cursor-pointer hover:bg-muted/50\" onClick={() => onSort('name')}>\n                            Name {sortConfig.column === 'name' && (sortConfig.direction === 'asc' ? '↑' : '↓')}\n                        </TableHead>\n                        <TableHead className=\"cursor-pointer hover:bg-muted/50\" onClick={() => onSort('owner')}>\n                            Owner\n                        </TableHead>\n                        <TableHead className=\"cursor-pointer hover:bg-muted/50\" onClick={() => onSort('modifiedAt')}>\n                            Last Modified\n                        </TableHead>\n                        <TableHead className=\"cursor-pointer hover:bg-muted/50\" onClick={() => onSort('sizeBytes')}>\n                            Size\n                        </TableHead>\n                        <TableHead className=\"w-[50px]\"></TableHead>\n                    </TableRow>\n                </TableHeader>\n                <TableBody>\n                    {files.map((file) => (\n                        <TableRow\n                            key={file.id}\n                            className=\"cursor-pointer\"\n                            onClick={() => onFileSelect(file)}\n                            onDoubleClick={(e) => {\n                                e.stopPropagation()\n                                if (file.type === 'folder') onFolderNavigate(file.id)\n                            }}\n                        >\n                            <TableCell className=\"font-medium\">\n                                <div className=\"flex items-center gap-3\">\n                                    <div\n                                        className=\"cursor-pointer\"\n                                        onClick={(e) => {\n                                            if (file.type === 'folder') {\n                                                e.stopPropagation()\n                                                onFolderNavigate(file.id)\n                                            }\n                                        }}\n                                    >\n                                        {getIcon(file.type)}\n                                    </div>\n                                    <span>{file.name}</span>\n                                </div>\n                            </TableCell>\n                            <TableCell>{file.owner}</TableCell>\n                            <TableCell>{new Date(file.modifiedAt).toLocaleDateString()}</TableCell>\n                            <TableCell>{formatSize(file.sizeBytes)}</TableCell>\n                            <TableCell onClick={(e) => e.stopPropagation()}>\n                                <DropdownMenu>\n                                    <DropdownMenuTrigger asChild>\n                                        <Button variant=\"ghost\" className=\"h-8 w-8 p-0\">\n                                            <span className=\"sr-only\">Open menu</span>\n                                            <MoreVertical className=\"h-4 w-4\" />\n                                        </Button>\n                                    </DropdownMenuTrigger>\n                                    <DropdownMenuContent align=\"end\">\n                                        <DropdownMenuItem onClick={() => onShare(file)}>\n                                            <Share2 className=\"mr-2 h-4 w-4\" /> Share\n                                        </DropdownMenuItem>\n                                        <DropdownMenuItem onClick={() => onDownload(file)}>\n                                            <Download className=\"mr-2 h-4 w-4\" /> Download\n                                        </DropdownMenuItem>\n                                        <DropdownMenuItem onClick={() => onRename(file.id)}>\n                                            <Pencil className=\"mr-2 h-4 w-4\" /> Rename\n                                        </DropdownMenuItem>\n                                        <DropdownMenuItem>\n                                            <Move className=\"mr-2 h-4 w-4\" /> Move\n                                        </DropdownMenuItem>\n                                        <DropdownMenuItem onClick={() => onCopyPath(file)}>\n                                            <Copy className=\"mr-2 h-4 w-4\" /> Copy Path\n                                        </DropdownMenuItem>\n                                        <DropdownMenuSeparator />\n                                        <DropdownMenuItem onClick={(e) => {\n                                            e.stopPropagation()\n                                            toast(\"Permissions\", { description: file.permissions })\n                                        }}>\n                                            <Shield className=\"mr-2 h-4 w-4\" /> Permissions\n                                        </DropdownMenuItem>\n                                        <DropdownMenuSeparator />\n                                        <DropdownMenuItem className=\"text-red-600\" onClick={() => onDelete(file.id)}>\n                                            <Trash2 className=\"mr-2 h-4 w-4\" /> Delete\n                                        </DropdownMenuItem>\n                                    </DropdownMenuContent>\n                                </DropdownMenu>\n                            </TableCell>\n                        </TableRow>\n                    ))}\n                </TableBody>\n            </Table>\n        </div>\n    )\n}\n"],"names":[],"mappings":";;;;;AAIA;AAQA;AAOA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AApCA;;;;;;;AAoDO,SAAS,SAAS,EACrB,KAAK,EACL,YAAY,EACZ,gBAAgB,EAChB,MAAM,EACN,UAAU,EACV,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,UAAU,EACV,UAAU,EACV,OAAO,EACK;IAEZ,MAAM,UAAU,CAAC;QACb,OAAQ;YACJ,KAAK;gBAAU,qBAAO,8OAAC,gNAAM;oBAAC,WAAU;;;;;;YACxC,KAAK;gBAAU,qBAAO,8OAAC,0NAAQ;oBAAC,WAAU;;;;;;YAC1C,KAAK;gBAAQ,qBAAO,8OAAC,sNAAQ;oBAAC,WAAU;;;;;;YACxC,KAAK;gBAAW,qBAAO,8OAAC,mNAAO;oBAAC,WAAU;;;;;;YAC1C;gBAAS,qBAAO,8OAAC,0NAAQ;oBAAC,WAAU;;;;;;QACxC;IACJ;IAEA,MAAM,aAAa,CAAC;QAChB,IAAI,UAAU,GAAG,OAAO;QACxB,MAAM,IAAI;QACV,MAAM,QAAQ;YAAC;YAAK;YAAM;YAAM;YAAM;SAAK;QAC3C,MAAM,IAAI,KAAK,KAAK,CAAC,KAAK,GAAG,CAAC,SAAS,KAAK,GAAG,CAAC;QAChD,OAAO,WAAW,CAAC,QAAQ,KAAK,GAAG,CAAC,GAAG,EAAE,EAAE,OAAO,CAAC,MAAM,MAAM,KAAK,CAAC,EAAE;IAC3E;IAEA,uFAAuF;IACvF,qEAAqE;IAErE,IAAI,aAAa,QAAQ;QACrB,qBACI,8OAAC;YAAI,WAAU;sBACV,MAAM,GAAG,CAAC,CAAC,qBACR,8OAAC;oBAEG,WAAU;oBACV,SAAS,IAAM,aAAa;oBAC5B,eAAe,CAAC;wBACZ,EAAE,eAAe;wBACjB,IAAI,KAAK,IAAI,KAAK,UAAU,iBAAiB,KAAK,EAAE;oBACxD;;sCAEA,8OAAC;4BACG,WAAU;4BACV,SAAS,CAAC;gCACN,IAAI,KAAK,IAAI,KAAK,UAAU;oCACxB,EAAE,eAAe;oCACjB,iBAAiB,KAAK,EAAE;gCAC5B;4BACJ;sCAEC,QAAQ,KAAK,IAAI;;;;;;sCAEtB,8OAAC;4BAAK,WAAU;4BAAuD,OAAO,KAAK,IAAI;sCAClF,KAAK,IAAI;;;;;;sCAEd,8OAAC;4BAAK,WAAU;sCACX,WAAW,KAAK,SAAS;;;;;;sCAG9B,8OAAC;4BAAI,WAAU;sCACX,cAAA,8OAAC,qJAAY;;kDACT,8OAAC,4JAAmB;wCAAC,OAAO;kDACxB,cAAA,8OAAC,qIAAM;4CAAC,SAAQ;4CAAQ,WAAU;sDAC9B,cAAA,8OAAC,0OAAY;gDAAC,WAAU;;;;;;;;;;;;;;;;kDAGhC,8OAAC,4JAAmB;wCAAC,OAAM;;0DACvB,8OAAC,yJAAgB;gDAAC,SAAS,IAAM,QAAQ;;kEACrC,8OAAC,oNAAM;wDAAC,WAAU;;;;;;oDAAiB;;;;;;;0DAEvC,8OAAC,yJAAgB;gDAAC,SAAS,IAAM,WAAW;;kEACxC,8OAAC,sNAAQ;wDAAC,WAAU;;;;;;oDAAiB;;;;;;;0DAEzC,8OAAC,yJAAgB;gDAAC,SAAS,IAAM,SAAS,KAAK,EAAE;;kEAC7C,8OAAC,gNAAM;wDAAC,WAAU;;;;;;oDAAiB;;;;;;;0DAEvC,8OAAC,yJAAgB;;kEACb,8OAAC,0MAAI;wDAAC,WAAU;;;;;;oDAAiB;;;;;;;0DAErC,8OAAC,yJAAgB;gDAAC,SAAS,IAAM,WAAW;;kEACxC,8OAAC,0MAAI;wDAAC,WAAU;;;;;;oDAAiB;;;;;;;0DAErC,8OAAC,8JAAqB;;;;;0DACtB,8OAAC,yJAAgB;gDAAC,SAAS,IAAM,IAAA,iJAAK,EAAC,eAAe;wDAAE,aAAa,KAAK,WAAW;oDAAC;;kEAClF,8OAAC,gNAAM;wDAAC,WAAU;;;;;;oDAAiB;;;;;;;0DAEvC,8OAAC,8JAAqB;;;;;0DACtB,8OAAC,yJAAgB;gDAAC,WAAU;gDAAe,SAAS,IAAM,SAAS,KAAK,EAAE;;kEACtE,8OAAC,oNAAM;wDAAC,WAAU;;;;;;oDAAiB;;;;;;;;;;;;;;;;;;;;;;;;;mBAvD9C,KAAK,EAAE;;;;;;;;;;IAgEhC;IAEA,qBACI,8OAAC;QAAI,WAAU;kBACX,cAAA,8OAAC,mIAAK;;8BACF,8OAAC,yIAAW;8BACR,cAAA,8OAAC,sIAAQ;;0CACL,8OAAC,uIAAS;gCAAC,WAAU;gCAA2C,SAAS,IAAM,OAAO;;oCAAS;oCACrF,WAAW,MAAM,KAAK,UAAU,CAAC,WAAW,SAAS,KAAK,QAAQ,MAAM,GAAG;;;;;;;0CAErF,8OAAC,uIAAS;gCAAC,WAAU;gCAAmC,SAAS,IAAM,OAAO;0CAAU;;;;;;0CAGxF,8OAAC,uIAAS;gCAAC,WAAU;gCAAmC,SAAS,IAAM,OAAO;0CAAe;;;;;;0CAG7F,8OAAC,uIAAS;gCAAC,WAAU;gCAAmC,SAAS,IAAM,OAAO;0CAAc;;;;;;0CAG5F,8OAAC,uIAAS;gCAAC,WAAU;;;;;;;;;;;;;;;;;8BAG7B,8OAAC,uIAAS;8BACL,MAAM,GAAG,CAAC,CAAC,qBACR,8OAAC,sIAAQ;4BAEL,WAAU;4BACV,SAAS,IAAM,aAAa;4BAC5B,eAAe,CAAC;gCACZ,EAAE,eAAe;gCACjB,IAAI,KAAK,IAAI,KAAK,UAAU,iBAAiB,KAAK,EAAE;4BACxD;;8CAEA,8OAAC,uIAAS;oCAAC,WAAU;8CACjB,cAAA,8OAAC;wCAAI,WAAU;;0DACX,8OAAC;gDACG,WAAU;gDACV,SAAS,CAAC;oDACN,IAAI,KAAK,IAAI,KAAK,UAAU;wDACxB,EAAE,eAAe;wDACjB,iBAAiB,KAAK,EAAE;oDAC5B;gDACJ;0DAEC,QAAQ,KAAK,IAAI;;;;;;0DAEtB,8OAAC;0DAAM,KAAK,IAAI;;;;;;;;;;;;;;;;;8CAGxB,8OAAC,uIAAS;8CAAE,KAAK,KAAK;;;;;;8CACtB,8OAAC,uIAAS;8CAAE,IAAI,KAAK,KAAK,UAAU,EAAE,kBAAkB;;;;;;8CACxD,8OAAC,uIAAS;8CAAE,WAAW,KAAK,SAAS;;;;;;8CACrC,8OAAC,uIAAS;oCAAC,SAAS,CAAC,IAAM,EAAE,eAAe;8CACxC,cAAA,8OAAC,qJAAY;;0DACT,8OAAC,4JAAmB;gDAAC,OAAO;0DACxB,cAAA,8OAAC,qIAAM;oDAAC,SAAQ;oDAAQ,WAAU;;sEAC9B,8OAAC;4DAAK,WAAU;sEAAU;;;;;;sEAC1B,8OAAC,0OAAY;4DAAC,WAAU;;;;;;;;;;;;;;;;;0DAGhC,8OAAC,4JAAmB;gDAAC,OAAM;;kEACvB,8OAAC,yJAAgB;wDAAC,SAAS,IAAM,QAAQ;;0EACrC,8OAAC,oNAAM;gEAAC,WAAU;;;;;;4DAAiB;;;;;;;kEAEvC,8OAAC,yJAAgB;wDAAC,SAAS,IAAM,WAAW;;0EACxC,8OAAC,sNAAQ;gEAAC,WAAU;;;;;;4DAAiB;;;;;;;kEAEzC,8OAAC,yJAAgB;wDAAC,SAAS,IAAM,SAAS,KAAK,EAAE;;0EAC7C,8OAAC,gNAAM;gEAAC,WAAU;;;;;;4DAAiB;;;;;;;kEAEvC,8OAAC,yJAAgB;;0EACb,8OAAC,0MAAI;gEAAC,WAAU;;;;;;4DAAiB;;;;;;;kEAErC,8OAAC,yJAAgB;wDAAC,SAAS,IAAM,WAAW;;0EACxC,8OAAC,0MAAI;gEAAC,WAAU;;;;;;4DAAiB;;;;;;;kEAErC,8OAAC,8JAAqB;;;;;kEACtB,8OAAC,yJAAgB;wDAAC,SAAS,CAAC;4DACxB,EAAE,eAAe;4DACjB,IAAA,iJAAK,EAAC,eAAe;gEAAE,aAAa,KAAK,WAAW;4DAAC;wDACzD;;0EACI,8OAAC,gNAAM;gEAAC,WAAU;;;;;;4DAAiB;;;;;;;kEAEvC,8OAAC,8JAAqB;;;;;kEACtB,8OAAC,yJAAgB;wDAAC,WAAU;wDAAe,SAAS,IAAM,SAAS,KAAK,EAAE;;0EACtE,8OAAC,oNAAM;gEAAC,WAAU;;;;;;4DAAiB;;;;;;;;;;;;;;;;;;;;;;;;;2BA5D9C,KAAK,EAAE;;;;;;;;;;;;;;;;;;;;;AAuExC"}},
    {"offset": {"line": 1435, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/components/ui/sheet.tsx"],"sourcesContent":["'use client'\n\nimport * as React from 'react'\nimport * as SheetPrimitive from '@radix-ui/react-dialog'\nimport { XIcon } from 'lucide-react'\n\nimport { cn } from '@/lib/utils'\n\nfunction Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {\n  return <SheetPrimitive.Root data-slot=\"sheet\" {...props} />\n}\n\nfunction SheetTrigger({\n  ...props\n}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {\n  return <SheetPrimitive.Trigger data-slot=\"sheet-trigger\" {...props} />\n}\n\nfunction SheetClose({\n  ...props\n}: React.ComponentProps<typeof SheetPrimitive.Close>) {\n  return <SheetPrimitive.Close data-slot=\"sheet-close\" {...props} />\n}\n\nfunction SheetPortal({\n  ...props\n}: React.ComponentProps<typeof SheetPrimitive.Portal>) {\n  return <SheetPrimitive.Portal data-slot=\"sheet-portal\" {...props} />\n}\n\nfunction SheetOverlay({\n  className,\n  ...props\n}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {\n  return (\n    <SheetPrimitive.Overlay\n      data-slot=\"sheet-overlay\"\n      className={cn(\n        'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction SheetContent({\n  className,\n  children,\n  side = 'right',\n  ...props\n}: React.ComponentProps<typeof SheetPrimitive.Content> & {\n  side?: 'top' | 'right' | 'bottom' | 'left'\n}) {\n  return (\n    <SheetPortal>\n      <SheetOverlay />\n      <SheetPrimitive.Content\n        data-slot=\"sheet-content\"\n        className={cn(\n          'bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500',\n          side === 'right' &&\n            'data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm',\n          side === 'left' &&\n            'data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm',\n          side === 'top' &&\n            'data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b',\n          side === 'bottom' &&\n            'data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t',\n          className,\n        )}\n        {...props}\n      >\n        {children}\n        <SheetPrimitive.Close className=\"ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none\">\n          <XIcon className=\"size-4\" />\n          <span className=\"sr-only\">Close</span>\n        </SheetPrimitive.Close>\n      </SheetPrimitive.Content>\n    </SheetPortal>\n  )\n}\n\nfunction SheetHeader({ className, ...props }: React.ComponentProps<'div'>) {\n  return (\n    <div\n      data-slot=\"sheet-header\"\n      className={cn('flex flex-col gap-1.5 p-4', className)}\n      {...props}\n    />\n  )\n}\n\nfunction SheetFooter({ className, ...props }: React.ComponentProps<'div'>) {\n  return (\n    <div\n      data-slot=\"sheet-footer\"\n      className={cn('mt-auto flex flex-col gap-2 p-4', className)}\n      {...props}\n    />\n  )\n}\n\nfunction SheetTitle({\n  className,\n  ...props\n}: React.ComponentProps<typeof SheetPrimitive.Title>) {\n  return (\n    <SheetPrimitive.Title\n      data-slot=\"sheet-title\"\n      className={cn('text-foreground font-semibold', className)}\n      {...props}\n    />\n  )\n}\n\nfunction SheetDescription({\n  className,\n  ...props\n}: React.ComponentProps<typeof SheetPrimitive.Description>) {\n  return (\n    <SheetPrimitive.Description\n      data-slot=\"sheet-description\"\n      className={cn('text-muted-foreground text-sm', className)}\n      {...props}\n    />\n  )\n}\n\nexport {\n  Sheet,\n  SheetTrigger,\n  SheetClose,\n  SheetContent,\n  SheetHeader,\n  SheetFooter,\n  SheetTitle,\n  SheetDescription,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAGA;AACA;AAEA;AANA;;;;;AAQA,SAAS,MAAM,EAAE,GAAG,OAAyD;IAC3E,qBAAO,8OAAC,0KAAmB;QAAC,aAAU;QAAS,GAAG,KAAK;;;;;;AACzD;AAEA,SAAS,aAAa,EACpB,GAAG,OACiD;IACpD,qBAAO,8OAAC,6KAAsB;QAAC,aAAU;QAAiB,GAAG,KAAK;;;;;;AACpE;AAEA,SAAS,WAAW,EAClB,GAAG,OAC+C;IAClD,qBAAO,8OAAC,2KAAoB;QAAC,aAAU;QAAe,GAAG,KAAK;;;;;;AAChE;AAEA,SAAS,YAAY,EACnB,GAAG,OACgD;IACnD,qBAAO,8OAAC,4KAAqB;QAAC,aAAU;QAAgB,GAAG,KAAK;;;;;;AAClE;AAEA,SAAS,aAAa,EACpB,SAAS,EACT,GAAG,OACiD;IACpD,qBACE,8OAAC,6KAAsB;QACrB,aAAU;QACV,WAAW,IAAA,kHAAE,EACX,0JACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,aAAa,EACpB,SAAS,EACT,QAAQ,EACR,OAAO,OAAO,EACd,GAAG,OAGJ;IACC,qBACE,8OAAC;;0BACC,8OAAC;;;;;0BACD,8OAAC,6KAAsB;gBACrB,aAAU;gBACV,WAAW,IAAA,kHAAE,EACX,8MACA,SAAS,WACP,oIACF,SAAS,UACP,iIACF,SAAS,SACP,4GACF,SAAS,YACP,qHACF;gBAED,GAAG,KAAK;;oBAER;kCACD,8OAAC,2KAAoB;wBAAC,WAAU;;0CAC9B,8OAAC,yMAAK;gCAAC,WAAU;;;;;;0CACjB,8OAAC;gCAAK,WAAU;0CAAU;;;;;;;;;;;;;;;;;;;;;;;;AAKpC;AAEA,SAAS,YAAY,EAAE,SAAS,EAAE,GAAG,OAAoC;IACvE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kHAAE,EAAC,6BAA6B;QAC1C,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,YAAY,EAAE,SAAS,EAAE,GAAG,OAAoC;IACvE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kHAAE,EAAC,mCAAmC;QAChD,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,WAAW,EAClB,SAAS,EACT,GAAG,OAC+C;IAClD,qBACE,8OAAC,2KAAoB;QACnB,aAAU;QACV,WAAW,IAAA,kHAAE,EAAC,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,iBAAiB,EACxB,SAAS,EACT,GAAG,OACqD;IACxD,qBACE,8OAAC,iLAA0B;QACzB,aAAU;QACV,WAAW,IAAA,kHAAE,EAAC,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGf"}},
    {"offset": {"line": 1613, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/components/ui/separator.tsx"],"sourcesContent":["'use client'\n\nimport * as React from 'react'\nimport * as SeparatorPrimitive from '@radix-ui/react-separator'\n\nimport { cn } from '@/lib/utils'\n\nfunction Separator({\n  className,\n  orientation = 'horizontal',\n  decorative = true,\n  ...props\n}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {\n  return (\n    <SeparatorPrimitive.Root\n      data-slot=\"separator\"\n      decorative={decorative}\n      orientation={orientation}\n      className={cn(\n        'bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Separator }\n"],"names":[],"mappings":";;;;;AAGA;AAEA;AALA;;;;AAOA,SAAS,UAAU,EACjB,SAAS,EACT,cAAc,YAAY,EAC1B,aAAa,IAAI,EACjB,GAAG,OACkD;IACrD,qBACE,8OAAC,6KAAuB;QACtB,aAAU;QACV,YAAY;QACZ,aAAa;QACb,WAAW,IAAA,kHAAE,EACX,kKACA;QAED,GAAG,KAAK;;;;;;AAGf"}},
    {"offset": {"line": 1642, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/app/actions.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs/promises'\nimport path from 'path'\nimport os from 'os'\nimport { FileItem } from '@/lib/mockData'\n\nconst BASE_PATH = os.homedir()\n\nexport async function getFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(BASE_PATH, relativePath)\n\n        // Security check: Ensure we don't escape home directory (basic check)\n        if (!fullPath.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied: Cannot traverse above home directory\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n                else if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n\n                // Permission string simulation (Node fs doesn't give \"rwx\" string directly easily across platforms, \n                // but we can approximate from mode)\n                const perms = (stats.mode & parseInt('777', 8)).toString(8) // simple octal\n\n                return {\n                    id: entryPath, // Use path as ID\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}` // Mocking the rwx string is complex, showing octal for now\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error reading directory:\", error)\n        return []\n    }\n}\n\nimport { exec } from 'child_process'\nimport util from 'util'\n\nconst execAsync = util.promisify(exec)\n\nconst usernameCache = new Map<number, string>()\n\nasync function getUsername(uid: number): Promise<string> {\n    if (usernameCache.has(uid)) return usernameCache.get(uid)!\n    try {\n        const { stdout } = await execAsync(`id -nu ${uid}`)\n        const name = stdout.trim()\n        usernameCache.set(uid, name)\n        return name\n    } catch (e) {\n        return String(uid)\n    }\n}\n\nasync function userExists(username: string): Promise<boolean> {\n    try {\n        await execAsync(`id -u ${username}`)\n        return true\n    } catch (error) {\n        return false\n    }\n}\n\nexport async function shareFile(sourcePath: string, targetUsername: string): Promise<{ success: boolean, message: string }> {\n    // Validate target user exists\n    if (!await userExists(targetUsername)) {\n        return { success: false, message: `User '${targetUsername}' does not exist on this system.` }\n    }\n\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const targetUserDir = path.join(sharedRoot, targetUsername)\n\n        // Ensure shared directories exist\n        await fs.mkdir(targetUserDir, { recursive: true })\n\n        const sourceName = path.basename(sourcePath)\n        const destPath = path.join(targetUserDir, sourceName)\n\n        try {\n            await fs.symlink(sourcePath, destPath)\n            return { success: true, message: `Successfully shared with ${targetUsername}` }\n        } catch (e: any) {\n            if (e.code === 'EEXIST') {\n                return { success: false, message: `Already shared with ${targetUsername}` }\n            }\n            throw e\n        }\n    } catch (error: any) {\n        console.error(\"Error sharing file:\", error)\n        return { success: false, message: error.message || \"Failed to share file\" }\n    }\n}\n\nexport async function getFileShares(filePath: string): Promise<string[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n\n        // Scan all user directories in shared root\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n            const shares: string[] = []\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            if (target === filePath) {\n                                shares.push(userDir.name)\n                            }\n                        } catch (e) {\n                            // Not a symlink or other error, ignore\n                        }\n                    }\n                } catch (e) {\n                    // Cannot read user dir, ignore\n                }\n            }\n            return shares\n        } catch (e) {\n            // Shared root likely doesn't exist yet\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting shares:\", error)\n        return []\n    }\n}\n\nexport async function getSharedFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const currentUser = os.userInfo().username\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared', currentUser)\n\n        await fs.mkdir(sharedRoot, { recursive: true })\n\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(sharedRoot, relativePath)\n\n        // Security check\n        if (!fullPath.startsWith(sharedRoot)) {\n            throw new Error(\"Access denied: Cannot traverse above shared root\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n\n                // For shared files, we might want to know who shared it (the link owner usually)\n                // but lstat on the link itself in the parent dir might be needed if we want link info.\n                // For now, presenting the target file info is fine.\n\n                // Determine type extension logic same as getFiles\n                if (!entry.isDirectory()) {\n                    if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                    else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                    else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n                }\n\n                const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                return {\n                    id: entryPath,\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}`\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error getting shared files:\", error)\n        return []\n    }\n}\n\nexport interface SharedFileItem extends FileItem {\n    sharedWith: { username: string, linkPath: string }[]\n}\n\nexport async function getOutgoingShares(): Promise<SharedFileItem[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const myHome = os.homedir()\n\n        // Map of sourcePath -> { sharedWith: [] }\n        const shareMap = new Map<string, { username: string, linkPath: string }[]>()\n\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            // Check if target is inside my home directory (or belongs to me)\n                            // Ideally check if I own the target file\n                            if (target.startsWith(myHome)) {\n                                if (!shareMap.has(target)) {\n                                    shareMap.set(target, [])\n                                }\n                                shareMap.get(target)?.push({ username: userDir.name, linkPath })\n                            }\n                        } catch (e) {\n                            // Not a symlink\n                        }\n                    }\n                } catch (e) {\n                    // Ignore\n                }\n            }\n\n            // Convert map to SharedFileItem list\n            const results: SharedFileItem[] = []\n            for (const [filePath, shares] of shareMap.entries()) {\n                try {\n                    const stats = await fs.stat(filePath)\n                    const name = path.basename(filePath)\n\n                    let type: FileItem['type'] = 'file'\n                    if (stats.isDirectory()) type = 'folder'\n                    else if (name.endsWith('.sh') || name.endsWith('.py')) type = 'script'\n                    else if (name.endsWith('.csv') || name.endsWith('.json')) type = 'data'\n                    else if (name.endsWith('.zip') || name.endsWith('.tar') || name.endsWith('.gz')) type = 'archive'\n\n                    const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                    results.push({\n                        id: filePath,\n                        name: name,\n                        type: type,\n                        path: filePath,\n                        owner: await getUsername(stats.uid),\n                        group: String(stats.gid),\n                        modifiedAt: stats.mtime.toISOString(),\n                        sizeBytes: stats.size,\n                        permissions: `0${perms}`,\n                        sharedWith: shares\n                    })\n                } catch (e) {\n                    // File might have been deleted but link exists\n                }\n            }\n            return results\n\n        } catch (e) {\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting outgoing shares:\", error)\n        return []\n    }\n}\n\nexport async function unshareFile(targetUsername: string, fileName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const sharedLinkPath = path.join(os.homedir(), 'hpc_shared', targetUsername, fileName)\n        await fs.unlink(sharedLinkPath)\n        return { success: true, message: `Unshared ${fileName} with ${targetUsername}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to unshare\" }\n    }\n}\n\nexport async function changePermissions(filePath: string, mode: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.chmod(filePath, mode)\n        return { success: true, message: `Updated permissions for ${path.basename(filePath)}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to change permissions\" }\n    }\n}\n\nexport async function uploadFile(formData: FormData): Promise<{ success: boolean, message: string }> {\n    try {\n        const file = formData.get('file') as File\n        const currentPathSegments = JSON.parse(formData.get('pathSegments') as string)\n\n        if (!file) {\n            throw new Error(\"No file provided\")\n        }\n\n        const buffer = Buffer.from(await file.arrayBuffer())\n        const relativePath = path.join(...currentPathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.writeFile(path.join(targetDir, file.name), buffer)\n        return { success: true, message: `Uploaded ${file.name}` }\n    } catch (error: any) {\n        console.error(\"Upload error:\", error)\n        return { success: false, message: error.message || \"Upload failed\" }\n    }\n}\n\nexport async function createFolder(pathSegments: string[], folderName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const relativePath = path.join(...pathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath, folderName)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.mkdir(targetDir)\n        return { success: true, message: `Created folder ${folderName}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to create folder\" }\n    }\n}\n\nexport async function deleteItem(itemPath: string): Promise<{ success: boolean, message: string }> {\n    return moveToTrash(itemPath) // Default to trash\n}\n\nconst TRASH_PATH = path.join(os.homedir(), '.hpc_trash')\n\nexport async function moveToTrash(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n\n        const timestamp = Date.now()\n        const trashName = `${path.basename(itemPath)}_${timestamp}`\n        const trashPath = path.join(TRASH_PATH, trashName)\n\n        // Store metadata for restoration\n        const metadata = {\n            originalPath: itemPath,\n            deletedAt: new Date().toISOString()\n        }\n        await fs.writeFile(`${trashPath}.meta`, JSON.stringify(metadata))\n\n        await fs.rename(itemPath, trashPath)\n        return { success: true, message: `Moved to trash` }\n    } catch (error: any) {\n        console.error(\"Trash error:\", error)\n        return { success: false, message: error.message || \"Failed to move to trash\" }\n    }\n}\n\nexport async function getTrashFiles(): Promise<FileItem[]> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n        const entries = await fs.readdir(TRASH_PATH)\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            if (entry.endsWith('.meta')) return null\n\n            try {\n                const entryPath = path.join(TRASH_PATH, entry)\n                const stats = await fs.stat(entryPath)\n                const name = entry.split('_').slice(0, -1).join('_') || entry // Attempt to recover name\n\n                return {\n                    id: entryPath,\n                    name: name,\n                    type: stats.isDirectory() ? 'folder' : 'file',\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: '000' // Trash items usually treated differently\n                } as FileItem\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (e) {\n        return []\n    }\n}\n\nexport async function restoreFromTrash(trashPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        // Try to read metadata\n        const metaPath = `${trashPath}.meta`\n        let targetPath = path.join(os.homedir(), path.basename(trashPath).split('_').slice(0, -1).join('_'))\n\n        try {\n            const metaContent = await fs.readFile(metaPath, 'utf-8')\n            const metadata = JSON.parse(metaContent)\n            targetPath = metadata.originalPath\n        } catch (e) {\n            // Fallback used above\n        }\n\n        // Check if target exists\n        try {\n            await fs.access(targetPath)\n            return { success: false, message: \"Original location occupied. Rename or move file first.\" }\n        } catch (e) {\n            // Good, target doesn't exist\n        }\n\n        await fs.rename(trashPath, targetPath)\n        try { await fs.unlink(metaPath) } catch (e) { } // Delete meta if exists\n\n        return { success: true, message: \"Restored successfully\" }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to restore\" }\n    }\n}\n\nexport async function permanentDelete(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        if (!itemPath.startsWith(TRASH_PATH)) {\n            throw new Error(\"Access denied: Can only permanent delete from trash\")\n        }\n        await fs.rm(itemPath, { recursive: true, force: true })\n        try { await fs.unlink(`${itemPath}.meta`) } catch (e) { }\n        return { success: true, message: \"Permanently deleted\" }\n    } catch (error: any) {\n        return { success: false, message: error.message }\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAsHsB,gBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 1654, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/components/DetailsDrawer.tsx"],"sourcesContent":["\n\"use client\"\n\nimport {\n    Sheet,\n    SheetContent,\n    SheetHeader,\n    SheetTitle,\n    SheetDescription,\n    SheetFooter,\n} from \"@/components/ui/sheet\"\nimport { Button } from \"@/components/ui/button\"\nimport { FileItem } from \"@/lib/mockData\"\nimport { Separator } from \"@/components/ui/separator\"\nimport {\n    FileText,\n    Folder,\n    Download,\n    Copy,\n    HardDrive,\n    Calendar,\n    User,\n    CheckCircle2,\n    Clock,\n\n    Shield,\n    FileCode,\n    Database,\n    Archive,\n    Share2\n} from \"lucide-react\"\nimport { getFileShares } from \"@/app/actions\"\nimport { useEffect, useState } from \"react\"\n\ninterface DetailsDrawerProps {\n    isOpen: boolean\n    onClose: () => void\n    file: FileItem | null\n    onCopyPath: (file: FileItem) => void\n    onDownload: (file: FileItem) => void\n    onShare: (file: FileItem) => void\n}\n\nexport function DetailsDrawer({ isOpen, onClose, file, onCopyPath, onDownload, onShare }: DetailsDrawerProps) {\n    const [shares, setShares] = useState<string[]>([])\n\n    useEffect(() => {\n        const loadShares = async () => {\n            if (file && isOpen) {\n                setShares([])\n                const sharedUsers = await getFileShares(file.path)\n                setShares(sharedUsers)\n            }\n        }\n        loadShares()\n    }, [file, isOpen])\n\n    if (!file) return null\n\n    const getIcon = (type: FileItem['type']) => {\n        switch (type) {\n            case 'folder': return <Folder className=\"h-10 w-10 text-blue-500\" />\n            case 'script': return <FileCode className=\"h-10 w-10 text-green-500\" />\n            case 'data': return <Database className=\"h-10 w-10 text-yellow-500\" />\n            case 'archive': return <Archive className=\"h-10 w-10 text-orange-500\" />\n            default: return <FileText className=\"h-10 w-10 text-gray-500\" />\n        }\n    }\n\n    const formatSize = (bytes: number) => {\n        if (bytes === 0) return \"-\"\n        const k = 1024\n        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']\n        const i = Math.floor(Math.log(bytes) / Math.log(k))\n        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]\n    }\n\n    return (\n        <Sheet open={isOpen} onOpenChange={onClose}>\n            <SheetContent className=\"w-[400px] sm:w-[540px]\">\n                <SheetHeader className=\"mb-6\">\n                    <div className=\"flex items-center gap-4\">\n                        {getIcon(file.type)}\n                        <div>\n                            <SheetTitle className=\"text-xl break-all\">{file.name}</SheetTitle>\n                            <SheetDescription>\n                                {file.path}\n                            </SheetDescription>\n                        </div>\n                    </div>\n                </SheetHeader>\n\n                <div className=\"space-y-6\">\n                    <div className=\"flex gap-2\">\n                        <Button className=\"flex-1 gap-2\" onClick={() => onDownload(file)}>\n                            <Download className=\"h-4 w-4\" />\n                            Download\n                        </Button>\n                        <Button variant=\"outline\" className=\"flex-1 gap-2\" onClick={() => onCopyPath(file)}>\n                            <Copy className=\"h-4 w-4\" />\n                            Copy Path\n                        </Button>\n                    </div>\n                    <Button variant=\"secondary\" className=\"w-full gap-2\" onClick={() => onShare(file)}>\n                        <Share2 className=\"h-4 w-4\" />\n                        Share (Symlink)\n                    </Button>\n\n                    {shares.length > 0 && (\n                        <div>\n                            <div className=\"text-sm font-medium mb-2\">Shared with</div>\n                            <div className=\"flex flex-wrap gap-2\">\n                                {shares.map(user => (\n                                    <div key={user} className=\"bg-secondary text-secondary-foreground text-xs px-2.5 py-0.5 rounded-full flex items-center gap-1\">\n                                        <User className=\"h-3 w-3\" />\n                                        {user}\n                                    </div>\n                                ))}\n                            </div>\n                        </div>\n                    )}\n\n                    <Separator />\n\n                    <div className=\"space-y-4\">\n                        <h3 className=\"font-semibold text-sm text-muted-foreground uppercase tracking-wider\">Details</h3>\n\n                        <div className=\"grid grid-cols-[24px_1fr_1fr] gap-4 items-center\">\n                            <HardDrive className=\"h-4 w-4 text-muted-foreground\" />\n                            <span className=\"text-sm font-medium\">Size</span>\n                            <span className=\"text-sm\">{formatSize(file.sizeBytes)}</span>\n\n                            <User className=\"h-4 w-4 text-muted-foreground\" />\n                            <span className=\"text-sm font-medium\">Owner / Group</span>\n                            <span className=\"text-sm\">{file.owner} : {file.group}</span>\n\n                            <Calendar className=\"h-4 w-4 text-muted-foreground\" />\n                            <span className=\"text-sm font-medium\">Modified</span>\n                            <span className=\"text-sm\">{new Date(file.modifiedAt).toLocaleDateString()}</span>\n\n                            <Shield className=\"h-4 w-4 text-muted-foreground\" />\n                            <span className=\"text-sm font-medium\">Permissions</span>\n                            <code className=\"text-xs bg-muted p-1 rounded font-mono\">{file.permissions}</code>\n\n                            <FileText className=\"h-4 w-4 text-muted-foreground\" />\n                            <span className=\"text-sm font-medium\">Type</span>\n                            <span className=\"text-sm capitalize\">{file.type}</span>\n                        </div>\n                    </div>\n                </div>\n\n                <SheetFooter className=\"mt-8\">\n                    {/* Add footer if needed */}\n                </SheetFooter>\n            </SheetContent>\n        </Sheet>\n    )\n}\n"],"names":[],"mappings":";;;;;AAGA;AAQA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA;AACA;AA/BA;;;;;;;;AA0CO,SAAS,cAAc,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,UAAU,EAAE,UAAU,EAAE,OAAO,EAAsB;IACxG,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,iNAAQ,EAAW,EAAE;IAEjD,IAAA,kNAAS,EAAC;QACN,MAAM,aAAa;YACf,IAAI,QAAQ,QAAQ;gBAChB,UAAU,EAAE;gBACZ,MAAM,cAAc,MAAM,IAAA,4JAAa,EAAC,KAAK,IAAI;gBACjD,UAAU;YACd;QACJ;QACA;IACJ,GAAG;QAAC;QAAM;KAAO;IAEjB,IAAI,CAAC,MAAM,OAAO;IAElB,MAAM,UAAU,CAAC;QACb,OAAQ;YACJ,KAAK;gBAAU,qBAAO,8OAAC,gNAAM;oBAAC,WAAU;;;;;;YACxC,KAAK;gBAAU,qBAAO,8OAAC,0NAAQ;oBAAC,WAAU;;;;;;YAC1C,KAAK;gBAAQ,qBAAO,8OAAC,sNAAQ;oBAAC,WAAU;;;;;;YACxC,KAAK;gBAAW,qBAAO,8OAAC,mNAAO;oBAAC,WAAU;;;;;;YAC1C;gBAAS,qBAAO,8OAAC,0NAAQ;oBAAC,WAAU;;;;;;QACxC;IACJ;IAEA,MAAM,aAAa,CAAC;QAChB,IAAI,UAAU,GAAG,OAAO;QACxB,MAAM,IAAI;QACV,MAAM,QAAQ;YAAC;YAAS;YAAM;YAAM;YAAM;SAAK;QAC/C,MAAM,IAAI,KAAK,KAAK,CAAC,KAAK,GAAG,CAAC,SAAS,KAAK,GAAG,CAAC;QAChD,OAAO,WAAW,CAAC,QAAQ,KAAK,GAAG,CAAC,GAAG,EAAE,EAAE,OAAO,CAAC,MAAM,MAAM,KAAK,CAAC,EAAE;IAC3E;IAEA,qBACI,8OAAC,mIAAK;QAAC,MAAM;QAAQ,cAAc;kBAC/B,cAAA,8OAAC,0IAAY;YAAC,WAAU;;8BACpB,8OAAC,yIAAW;oBAAC,WAAU;8BACnB,cAAA,8OAAC;wBAAI,WAAU;;4BACV,QAAQ,KAAK,IAAI;0CAClB,8OAAC;;kDACG,8OAAC,wIAAU;wCAAC,WAAU;kDAAqB,KAAK,IAAI;;;;;;kDACpD,8OAAC,8IAAgB;kDACZ,KAAK,IAAI;;;;;;;;;;;;;;;;;;;;;;;8BAM1B,8OAAC;oBAAI,WAAU;;sCACX,8OAAC;4BAAI,WAAU;;8CACX,8OAAC,qIAAM;oCAAC,WAAU;oCAAe,SAAS,IAAM,WAAW;;sDACvD,8OAAC,sNAAQ;4CAAC,WAAU;;;;;;wCAAY;;;;;;;8CAGpC,8OAAC,qIAAM;oCAAC,SAAQ;oCAAU,WAAU;oCAAe,SAAS,IAAM,WAAW;;sDACzE,8OAAC,0MAAI;4CAAC,WAAU;;;;;;wCAAY;;;;;;;;;;;;;sCAIpC,8OAAC,qIAAM;4BAAC,SAAQ;4BAAY,WAAU;4BAAe,SAAS,IAAM,QAAQ;;8CACxE,8OAAC,oNAAM;oCAAC,WAAU;;;;;;gCAAY;;;;;;;wBAIjC,OAAO,MAAM,GAAG,mBACb,8OAAC;;8CACG,8OAAC;oCAAI,WAAU;8CAA2B;;;;;;8CAC1C,8OAAC;oCAAI,WAAU;8CACV,OAAO,GAAG,CAAC,CAAA,qBACR,8OAAC;4CAAe,WAAU;;8DACtB,8OAAC,0MAAI;oDAAC,WAAU;;;;;;gDACf;;2CAFK;;;;;;;;;;;;;;;;sCAS1B,8OAAC,2IAAS;;;;;sCAEV,8OAAC;4BAAI,WAAU;;8CACX,8OAAC;oCAAG,WAAU;8CAAuE;;;;;;8CAErF,8OAAC;oCAAI,WAAU;;sDACX,8OAAC,6NAAS;4CAAC,WAAU;;;;;;sDACrB,8OAAC;4CAAK,WAAU;sDAAsB;;;;;;sDACtC,8OAAC;4CAAK,WAAU;sDAAW,WAAW,KAAK,SAAS;;;;;;sDAEpD,8OAAC,0MAAI;4CAAC,WAAU;;;;;;sDAChB,8OAAC;4CAAK,WAAU;sDAAsB;;;;;;sDACtC,8OAAC;4CAAK,WAAU;;gDAAW,KAAK,KAAK;gDAAC;gDAAI,KAAK,KAAK;;;;;;;sDAEpD,8OAAC,sNAAQ;4CAAC,WAAU;;;;;;sDACpB,8OAAC;4CAAK,WAAU;sDAAsB;;;;;;sDACtC,8OAAC;4CAAK,WAAU;sDAAW,IAAI,KAAK,KAAK,UAAU,EAAE,kBAAkB;;;;;;sDAEvE,8OAAC,gNAAM;4CAAC,WAAU;;;;;;sDAClB,8OAAC;4CAAK,WAAU;sDAAsB;;;;;;sDACtC,8OAAC;4CAAK,WAAU;sDAA0C,KAAK,WAAW;;;;;;sDAE1E,8OAAC,0NAAQ;4CAAC,WAAU;;;;;;sDACpB,8OAAC;4CAAK,WAAU;sDAAsB;;;;;;sDACtC,8OAAC;4CAAK,WAAU;sDAAsB,KAAK,IAAI;;;;;;;;;;;;;;;;;;;;;;;;8BAK3D,8OAAC,yIAAW;oBAAC,WAAU;;;;;;;;;;;;;;;;;AAMvC"}},
    {"offset": {"line": 2090, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/components/ui/dialog.tsx"],"sourcesContent":["'use client'\n\nimport * as React from 'react'\nimport * as DialogPrimitive from '@radix-ui/react-dialog'\nimport { XIcon } from 'lucide-react'\n\nimport { cn } from '@/lib/utils'\n\nfunction Dialog({\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Root>) {\n  return <DialogPrimitive.Root data-slot=\"dialog\" {...props} />\n}\n\nfunction DialogTrigger({\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {\n  return <DialogPrimitive.Trigger data-slot=\"dialog-trigger\" {...props} />\n}\n\nfunction DialogPortal({\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Portal>) {\n  return <DialogPrimitive.Portal data-slot=\"dialog-portal\" {...props} />\n}\n\nfunction DialogClose({\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Close>) {\n  return <DialogPrimitive.Close data-slot=\"dialog-close\" {...props} />\n}\n\nfunction DialogOverlay({\n  className,\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {\n  return (\n    <DialogPrimitive.Overlay\n      data-slot=\"dialog-overlay\"\n      className={cn(\n        'data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction DialogContent({\n  className,\n  children,\n  showCloseButton = true,\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Content> & {\n  showCloseButton?: boolean\n}) {\n  return (\n    <DialogPortal data-slot=\"dialog-portal\">\n      <DialogOverlay />\n      <DialogPrimitive.Content\n        data-slot=\"dialog-content\"\n        className={cn(\n          'bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg',\n          className,\n        )}\n        {...props}\n      >\n        {children}\n        {showCloseButton && (\n          <DialogPrimitive.Close\n            data-slot=\"dialog-close\"\n            className=\"ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\"\n          >\n            <XIcon />\n            <span className=\"sr-only\">Close</span>\n          </DialogPrimitive.Close>\n        )}\n      </DialogPrimitive.Content>\n    </DialogPortal>\n  )\n}\n\nfunction DialogHeader({ className, ...props }: React.ComponentProps<'div'>) {\n  return (\n    <div\n      data-slot=\"dialog-header\"\n      className={cn('flex flex-col gap-2 text-center sm:text-left', className)}\n      {...props}\n    />\n  )\n}\n\nfunction DialogFooter({ className, ...props }: React.ComponentProps<'div'>) {\n  return (\n    <div\n      data-slot=\"dialog-footer\"\n      className={cn(\n        'flex flex-col-reverse gap-2 sm:flex-row sm:justify-end',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction DialogTitle({\n  className,\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Title>) {\n  return (\n    <DialogPrimitive.Title\n      data-slot=\"dialog-title\"\n      className={cn('text-lg leading-none font-semibold', className)}\n      {...props}\n    />\n  )\n}\n\nfunction DialogDescription({\n  className,\n  ...props\n}: React.ComponentProps<typeof DialogPrimitive.Description>) {\n  return (\n    <DialogPrimitive.Description\n      data-slot=\"dialog-description\"\n      className={cn('text-muted-foreground text-sm', className)}\n      {...props}\n    />\n  )\n}\n\nexport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogOverlay,\n  DialogPortal,\n  DialogTitle,\n  DialogTrigger,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAGA;AACA;AAEA;AANA;;;;;AAQA,SAAS,OAAO,EACd,GAAG,OAC+C;IAClD,qBAAO,8OAAC,0KAAoB;QAAC,aAAU;QAAU,GAAG,KAAK;;;;;;AAC3D;AAEA,SAAS,cAAc,EACrB,GAAG,OACkD;IACrD,qBAAO,8OAAC,6KAAuB;QAAC,aAAU;QAAkB,GAAG,KAAK;;;;;;AACtE;AAEA,SAAS,aAAa,EACpB,GAAG,OACiD;IACpD,qBAAO,8OAAC,4KAAsB;QAAC,aAAU;QAAiB,GAAG,KAAK;;;;;;AACpE;AAEA,SAAS,YAAY,EACnB,GAAG,OACgD;IACnD,qBAAO,8OAAC,2KAAqB;QAAC,aAAU;QAAgB,GAAG,KAAK;;;;;;AAClE;AAEA,SAAS,cAAc,EACrB,SAAS,EACT,GAAG,OACkD;IACrD,qBACE,8OAAC,6KAAuB;QACtB,aAAU;QACV,WAAW,IAAA,kHAAE,EACX,0JACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,cAAc,EACrB,SAAS,EACT,QAAQ,EACR,kBAAkB,IAAI,EACtB,GAAG,OAGJ;IACC,qBACE,8OAAC;QAAa,aAAU;;0BACtB,8OAAC;;;;;0BACD,8OAAC,6KAAuB;gBACtB,aAAU;gBACV,WAAW,IAAA,kHAAE,EACX,+WACA;gBAED,GAAG,KAAK;;oBAER;oBACA,iCACC,8OAAC,2KAAqB;wBACpB,aAAU;wBACV,WAAU;;0CAEV,8OAAC,yMAAK;;;;;0CACN,8OAAC;gCAAK,WAAU;0CAAU;;;;;;;;;;;;;;;;;;;;;;;;AAMtC;AAEA,SAAS,aAAa,EAAE,SAAS,EAAE,GAAG,OAAoC;IACxE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kHAAE,EAAC,gDAAgD;QAC7D,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,aAAa,EAAE,SAAS,EAAE,GAAG,OAAoC;IACxE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kHAAE,EACX,0DACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,YAAY,EACnB,SAAS,EACT,GAAG,OACgD;IACnD,qBACE,8OAAC,2KAAqB;QACpB,aAAU;QACV,WAAW,IAAA,kHAAE,EAAC,sCAAsC;QACnD,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,kBAAkB,EACzB,SAAS,EACT,GAAG,OACsD;IACzD,qBACE,8OAAC,iLAA2B;QAC1B,aAAU;QACV,WAAW,IAAA,kHAAE,EAAC,iCAAiC;QAC9C,GAAG,KAAK;;;;;;AAGf"}},
    {"offset": {"line": 2272, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/components/ui/input.tsx"],"sourcesContent":["import * as React from 'react'\n\nimport { cn } from '@/lib/utils'\n\nfunction Input({ className, type, ...props }: React.ComponentProps<'input'>) {\n  return (\n    <input\n      type={type}\n      data-slot=\"input\"\n      className={cn(\n        'file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',\n        'focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]',\n        'aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Input }\n"],"names":[],"mappings":";;;;;AAEA;;;AAEA,SAAS,MAAM,EAAE,SAAS,EAAE,IAAI,EAAE,GAAG,OAAsC;IACzE,qBACE,8OAAC;QACC,MAAM;QACN,aAAU;QACV,WAAW,IAAA,kHAAE,EACX,8bACA,iFACA,0GACA;QAED,GAAG,KAAK;;;;;;AAGf"}},
    {"offset": {"line": 2297, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/components/ui/label.tsx"],"sourcesContent":["'use client'\n\nimport * as React from 'react'\nimport * as LabelPrimitive from '@radix-ui/react-label'\n\nimport { cn } from '@/lib/utils'\n\nfunction Label({\n  className,\n  ...props\n}: React.ComponentProps<typeof LabelPrimitive.Root>) {\n  return (\n    <LabelPrimitive.Root\n      data-slot=\"label\"\n      className={cn(\n        'flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Label }\n"],"names":[],"mappings":";;;;;AAGA;AAEA;AALA;;;;AAOA,SAAS,MAAM,EACb,SAAS,EACT,GAAG,OAC8C;IACjD,qBACE,8OAAC,yKAAmB;QAClB,aAAU;QACV,WAAW,IAAA,kHAAE,EACX,uNACA;QAED,GAAG,KAAK;;;;;;AAGf"}},
    {"offset": {"line": 2324, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/components/ShareDialog.tsx"],"sourcesContent":["\"use client\"\n\nimport { useState, useEffect } from \"react\"\nimport {\n    Dialog,\n    DialogContent,\n    DialogDescription,\n    DialogFooter,\n    DialogHeader,\n    DialogTitle,\n} from \"@/components/ui/dialog\"\nimport { Input } from \"@/components/ui/input\"\nimport { Button } from \"@/components/ui/button\"\nimport { Label } from \"@/components/ui/label\"\nimport { FileItem } from \"@/lib/mockData\"\n\ninterface ShareDialogProps {\n    isOpen: boolean\n    onClose: () => void\n    onConfirm: (username: string) => Promise<void> // Confirm is async\n    file: FileItem | null\n}\n\nexport function ShareDialog({ isOpen, onClose, onConfirm, file }: ShareDialogProps) {\n    const [username, setUsername] = useState(\"\")\n    const [isLoading, setIsLoading] = useState(false)\n\n    // Reset username when dialog opens\n    useEffect(() => {\n        if (isOpen) setUsername(\"\")\n    }, [isOpen])\n\n    const handleConfirm = async () => {\n        if (!username.trim()) return\n\n        setIsLoading(true)\n        try {\n            await onConfirm(username)\n            onClose()\n        } catch (error) {\n            // Error handling should be done by parent (e.g. showing toast), \n            // but we ensure we stop loading state if error happens here or just finish.\n            // Actually parent catches error for Toast, so we usually just finish.\n        } finally {\n            setIsLoading(false)\n        }\n    }\n\n    if (!file) return null\n\n    return (\n        <Dialog open={isOpen} onOpenChange={onClose}>\n            <DialogContent className=\"sm:max-w-[425px]\">\n                <DialogHeader>\n                    <DialogTitle>Share File</DialogTitle>\n                    <DialogDescription>\n                        Create a symlink for <b>{file.name}</b> in another user's shared folder.\n                    </DialogDescription>\n                </DialogHeader>\n                <div className=\"grid gap-4 py-4\">\n                    <div className=\"grid grid-cols-4 items-center gap-4\">\n                        <Label htmlFor=\"username\" className=\"text-right\">\n                            Username\n                        </Label>\n                        <Input\n                            id=\"username\"\n                            value={username}\n                            onChange={(e) => setUsername(e.target.value)}\n                            className=\"col-span-3\"\n                            placeholder=\"e.g. alice\"\n                            onKeyDown={(e) => {\n                                if (e.key === \"Enter\") handleConfirm()\n                            }}\n                        />\n                    </div>\n                </div>\n                <DialogFooter>\n                    <Button variant=\"outline\" onClick={onClose} disabled={isLoading}>\n                        Cancel\n                    </Button>\n                    <Button onClick={handleConfirm} disabled={!username.trim() || isLoading}>\n                        {isLoading ? \"Sharing...\" : \"Share\"}\n                    </Button>\n                </DialogFooter>\n            </DialogContent>\n        </Dialog>\n    )\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAQA;AACA;AACA;AAbA;;;;;;;AAuBO,SAAS,YAAY,EAAE,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,IAAI,EAAoB;IAC9E,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,iNAAQ,EAAC;IACzC,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,iNAAQ,EAAC;IAE3C,mCAAmC;IACnC,IAAA,kNAAS,EAAC;QACN,IAAI,QAAQ,YAAY;IAC5B,GAAG;QAAC;KAAO;IAEX,MAAM,gBAAgB;QAClB,IAAI,CAAC,SAAS,IAAI,IAAI;QAEtB,aAAa;QACb,IAAI;YACA,MAAM,UAAU;YAChB;QACJ,EAAE,OAAO,OAAO;QACZ,iEAAiE;QACjE,4EAA4E;QAC5E,sEAAsE;QAC1E,SAAU;YACN,aAAa;QACjB;IACJ;IAEA,IAAI,CAAC,MAAM,OAAO;IAElB,qBACI,8OAAC,qIAAM;QAAC,MAAM;QAAQ,cAAc;kBAChC,cAAA,8OAAC,4IAAa;YAAC,WAAU;;8BACrB,8OAAC,2IAAY;;sCACT,8OAAC,0IAAW;sCAAC;;;;;;sCACb,8OAAC,gJAAiB;;gCAAC;8CACM,8OAAC;8CAAG,KAAK,IAAI;;;;;;gCAAK;;;;;;;;;;;;;8BAG/C,8OAAC;oBAAI,WAAU;8BACX,cAAA,8OAAC;wBAAI,WAAU;;0CACX,8OAAC,mIAAK;gCAAC,SAAQ;gCAAW,WAAU;0CAAa;;;;;;0CAGjD,8OAAC,mIAAK;gCACF,IAAG;gCACH,OAAO;gCACP,UAAU,CAAC,IAAM,YAAY,EAAE,MAAM,CAAC,KAAK;gCAC3C,WAAU;gCACV,aAAY;gCACZ,WAAW,CAAC;oCACR,IAAI,EAAE,GAAG,KAAK,SAAS;gCAC3B;;;;;;;;;;;;;;;;;8BAIZ,8OAAC,2IAAY;;sCACT,8OAAC,qIAAM;4BAAC,SAAQ;4BAAU,SAAS;4BAAS,UAAU;sCAAW;;;;;;sCAGjE,8OAAC,qIAAM;4BAAC,SAAS;4BAAe,UAAU,CAAC,SAAS,IAAI,MAAM;sCACzD,YAAY,eAAe;;;;;;;;;;;;;;;;;;;;;;;AAMpD"}},
    {"offset": {"line": 2485, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/app/actions.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs/promises'\nimport path from 'path'\nimport os from 'os'\nimport { FileItem } from '@/lib/mockData'\n\nconst BASE_PATH = os.homedir()\n\nexport async function getFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(BASE_PATH, relativePath)\n\n        // Security check: Ensure we don't escape home directory (basic check)\n        if (!fullPath.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied: Cannot traverse above home directory\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n                else if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n\n                // Permission string simulation (Node fs doesn't give \"rwx\" string directly easily across platforms, \n                // but we can approximate from mode)\n                const perms = (stats.mode & parseInt('777', 8)).toString(8) // simple octal\n\n                return {\n                    id: entryPath, // Use path as ID\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}` // Mocking the rwx string is complex, showing octal for now\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error reading directory:\", error)\n        return []\n    }\n}\n\nimport { exec } from 'child_process'\nimport util from 'util'\n\nconst execAsync = util.promisify(exec)\n\nconst usernameCache = new Map<number, string>()\n\nasync function getUsername(uid: number): Promise<string> {\n    if (usernameCache.has(uid)) return usernameCache.get(uid)!\n    try {\n        const { stdout } = await execAsync(`id -nu ${uid}`)\n        const name = stdout.trim()\n        usernameCache.set(uid, name)\n        return name\n    } catch (e) {\n        return String(uid)\n    }\n}\n\nasync function userExists(username: string): Promise<boolean> {\n    try {\n        await execAsync(`id -u ${username}`)\n        return true\n    } catch (error) {\n        return false\n    }\n}\n\nexport async function shareFile(sourcePath: string, targetUsername: string): Promise<{ success: boolean, message: string }> {\n    // Validate target user exists\n    if (!await userExists(targetUsername)) {\n        return { success: false, message: `User '${targetUsername}' does not exist on this system.` }\n    }\n\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const targetUserDir = path.join(sharedRoot, targetUsername)\n\n        // Ensure shared directories exist\n        await fs.mkdir(targetUserDir, { recursive: true })\n\n        const sourceName = path.basename(sourcePath)\n        const destPath = path.join(targetUserDir, sourceName)\n\n        try {\n            await fs.symlink(sourcePath, destPath)\n            return { success: true, message: `Successfully shared with ${targetUsername}` }\n        } catch (e: any) {\n            if (e.code === 'EEXIST') {\n                return { success: false, message: `Already shared with ${targetUsername}` }\n            }\n            throw e\n        }\n    } catch (error: any) {\n        console.error(\"Error sharing file:\", error)\n        return { success: false, message: error.message || \"Failed to share file\" }\n    }\n}\n\nexport async function getFileShares(filePath: string): Promise<string[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n\n        // Scan all user directories in shared root\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n            const shares: string[] = []\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            if (target === filePath) {\n                                shares.push(userDir.name)\n                            }\n                        } catch (e) {\n                            // Not a symlink or other error, ignore\n                        }\n                    }\n                } catch (e) {\n                    // Cannot read user dir, ignore\n                }\n            }\n            return shares\n        } catch (e) {\n            // Shared root likely doesn't exist yet\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting shares:\", error)\n        return []\n    }\n}\n\nexport async function getSharedFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const currentUser = os.userInfo().username\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared', currentUser)\n\n        await fs.mkdir(sharedRoot, { recursive: true })\n\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(sharedRoot, relativePath)\n\n        // Security check\n        if (!fullPath.startsWith(sharedRoot)) {\n            throw new Error(\"Access denied: Cannot traverse above shared root\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n\n                // For shared files, we might want to know who shared it (the link owner usually)\n                // but lstat on the link itself in the parent dir might be needed if we want link info.\n                // For now, presenting the target file info is fine.\n\n                // Determine type extension logic same as getFiles\n                if (!entry.isDirectory()) {\n                    if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                    else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                    else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n                }\n\n                const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                return {\n                    id: entryPath,\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}`\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error getting shared files:\", error)\n        return []\n    }\n}\n\nexport interface SharedFileItem extends FileItem {\n    sharedWith: { username: string, linkPath: string }[]\n}\n\nexport async function getOutgoingShares(): Promise<SharedFileItem[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const myHome = os.homedir()\n\n        // Map of sourcePath -> { sharedWith: [] }\n        const shareMap = new Map<string, { username: string, linkPath: string }[]>()\n\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            // Check if target is inside my home directory (or belongs to me)\n                            // Ideally check if I own the target file\n                            if (target.startsWith(myHome)) {\n                                if (!shareMap.has(target)) {\n                                    shareMap.set(target, [])\n                                }\n                                shareMap.get(target)?.push({ username: userDir.name, linkPath })\n                            }\n                        } catch (e) {\n                            // Not a symlink\n                        }\n                    }\n                } catch (e) {\n                    // Ignore\n                }\n            }\n\n            // Convert map to SharedFileItem list\n            const results: SharedFileItem[] = []\n            for (const [filePath, shares] of shareMap.entries()) {\n                try {\n                    const stats = await fs.stat(filePath)\n                    const name = path.basename(filePath)\n\n                    let type: FileItem['type'] = 'file'\n                    if (stats.isDirectory()) type = 'folder'\n                    else if (name.endsWith('.sh') || name.endsWith('.py')) type = 'script'\n                    else if (name.endsWith('.csv') || name.endsWith('.json')) type = 'data'\n                    else if (name.endsWith('.zip') || name.endsWith('.tar') || name.endsWith('.gz')) type = 'archive'\n\n                    const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                    results.push({\n                        id: filePath,\n                        name: name,\n                        type: type,\n                        path: filePath,\n                        owner: await getUsername(stats.uid),\n                        group: String(stats.gid),\n                        modifiedAt: stats.mtime.toISOString(),\n                        sizeBytes: stats.size,\n                        permissions: `0${perms}`,\n                        sharedWith: shares\n                    })\n                } catch (e) {\n                    // File might have been deleted but link exists\n                }\n            }\n            return results\n\n        } catch (e) {\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting outgoing shares:\", error)\n        return []\n    }\n}\n\nexport async function unshareFile(targetUsername: string, fileName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const sharedLinkPath = path.join(os.homedir(), 'hpc_shared', targetUsername, fileName)\n        await fs.unlink(sharedLinkPath)\n        return { success: true, message: `Unshared ${fileName} with ${targetUsername}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to unshare\" }\n    }\n}\n\nexport async function changePermissions(filePath: string, mode: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.chmod(filePath, mode)\n        return { success: true, message: `Updated permissions for ${path.basename(filePath)}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to change permissions\" }\n    }\n}\n\nexport async function uploadFile(formData: FormData): Promise<{ success: boolean, message: string }> {\n    try {\n        const file = formData.get('file') as File\n        const currentPathSegments = JSON.parse(formData.get('pathSegments') as string)\n\n        if (!file) {\n            throw new Error(\"No file provided\")\n        }\n\n        const buffer = Buffer.from(await file.arrayBuffer())\n        const relativePath = path.join(...currentPathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.writeFile(path.join(targetDir, file.name), buffer)\n        return { success: true, message: `Uploaded ${file.name}` }\n    } catch (error: any) {\n        console.error(\"Upload error:\", error)\n        return { success: false, message: error.message || \"Upload failed\" }\n    }\n}\n\nexport async function createFolder(pathSegments: string[], folderName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const relativePath = path.join(...pathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath, folderName)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.mkdir(targetDir)\n        return { success: true, message: `Created folder ${folderName}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to create folder\" }\n    }\n}\n\nexport async function deleteItem(itemPath: string): Promise<{ success: boolean, message: string }> {\n    return moveToTrash(itemPath) // Default to trash\n}\n\nconst TRASH_PATH = path.join(os.homedir(), '.hpc_trash')\n\nexport async function moveToTrash(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n\n        const timestamp = Date.now()\n        const trashName = `${path.basename(itemPath)}_${timestamp}`\n        const trashPath = path.join(TRASH_PATH, trashName)\n\n        // Store metadata for restoration\n        const metadata = {\n            originalPath: itemPath,\n            deletedAt: new Date().toISOString()\n        }\n        await fs.writeFile(`${trashPath}.meta`, JSON.stringify(metadata))\n\n        await fs.rename(itemPath, trashPath)\n        return { success: true, message: `Moved to trash` }\n    } catch (error: any) {\n        console.error(\"Trash error:\", error)\n        return { success: false, message: error.message || \"Failed to move to trash\" }\n    }\n}\n\nexport async function getTrashFiles(): Promise<FileItem[]> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n        const entries = await fs.readdir(TRASH_PATH)\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            if (entry.endsWith('.meta')) return null\n\n            try {\n                const entryPath = path.join(TRASH_PATH, entry)\n                const stats = await fs.stat(entryPath)\n                const name = entry.split('_').slice(0, -1).join('_') || entry // Attempt to recover name\n\n                return {\n                    id: entryPath,\n                    name: name,\n                    type: stats.isDirectory() ? 'folder' : 'file',\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: '000' // Trash items usually treated differently\n                } as FileItem\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (e) {\n        return []\n    }\n}\n\nexport async function restoreFromTrash(trashPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        // Try to read metadata\n        const metaPath = `${trashPath}.meta`\n        let targetPath = path.join(os.homedir(), path.basename(trashPath).split('_').slice(0, -1).join('_'))\n\n        try {\n            const metaContent = await fs.readFile(metaPath, 'utf-8')\n            const metadata = JSON.parse(metaContent)\n            targetPath = metadata.originalPath\n        } catch (e) {\n            // Fallback used above\n        }\n\n        // Check if target exists\n        try {\n            await fs.access(targetPath)\n            return { success: false, message: \"Original location occupied. Rename or move file first.\" }\n        } catch (e) {\n            // Good, target doesn't exist\n        }\n\n        await fs.rename(trashPath, targetPath)\n        try { await fs.unlink(metaPath) } catch (e) { } // Delete meta if exists\n\n        return { success: true, message: \"Restored successfully\" }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to restore\" }\n    }\n}\n\nexport async function permanentDelete(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        if (!itemPath.startsWith(TRASH_PATH)) {\n            throw new Error(\"Access denied: Can only permanent delete from trash\")\n        }\n        await fs.rm(itemPath, { recursive: true, force: true })\n        try { await fs.unlink(`${itemPath}.meta`) } catch (e) { }\n        return { success: true, message: \"Permanently deleted\" }\n    } catch (error: any) {\n        return { success: false, message: error.message }\n    }\n}\n"],"names":[],"mappings":";;;;;;;IASsB,WAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 2497, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/app/actions.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs/promises'\nimport path from 'path'\nimport os from 'os'\nimport { FileItem } from '@/lib/mockData'\n\nconst BASE_PATH = os.homedir()\n\nexport async function getFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(BASE_PATH, relativePath)\n\n        // Security check: Ensure we don't escape home directory (basic check)\n        if (!fullPath.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied: Cannot traverse above home directory\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n                else if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n\n                // Permission string simulation (Node fs doesn't give \"rwx\" string directly easily across platforms, \n                // but we can approximate from mode)\n                const perms = (stats.mode & parseInt('777', 8)).toString(8) // simple octal\n\n                return {\n                    id: entryPath, // Use path as ID\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}` // Mocking the rwx string is complex, showing octal for now\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error reading directory:\", error)\n        return []\n    }\n}\n\nimport { exec } from 'child_process'\nimport util from 'util'\n\nconst execAsync = util.promisify(exec)\n\nconst usernameCache = new Map<number, string>()\n\nasync function getUsername(uid: number): Promise<string> {\n    if (usernameCache.has(uid)) return usernameCache.get(uid)!\n    try {\n        const { stdout } = await execAsync(`id -nu ${uid}`)\n        const name = stdout.trim()\n        usernameCache.set(uid, name)\n        return name\n    } catch (e) {\n        return String(uid)\n    }\n}\n\nasync function userExists(username: string): Promise<boolean> {\n    try {\n        await execAsync(`id -u ${username}`)\n        return true\n    } catch (error) {\n        return false\n    }\n}\n\nexport async function shareFile(sourcePath: string, targetUsername: string): Promise<{ success: boolean, message: string }> {\n    // Validate target user exists\n    if (!await userExists(targetUsername)) {\n        return { success: false, message: `User '${targetUsername}' does not exist on this system.` }\n    }\n\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const targetUserDir = path.join(sharedRoot, targetUsername)\n\n        // Ensure shared directories exist\n        await fs.mkdir(targetUserDir, { recursive: true })\n\n        const sourceName = path.basename(sourcePath)\n        const destPath = path.join(targetUserDir, sourceName)\n\n        try {\n            await fs.symlink(sourcePath, destPath)\n            return { success: true, message: `Successfully shared with ${targetUsername}` }\n        } catch (e: any) {\n            if (e.code === 'EEXIST') {\n                return { success: false, message: `Already shared with ${targetUsername}` }\n            }\n            throw e\n        }\n    } catch (error: any) {\n        console.error(\"Error sharing file:\", error)\n        return { success: false, message: error.message || \"Failed to share file\" }\n    }\n}\n\nexport async function getFileShares(filePath: string): Promise<string[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n\n        // Scan all user directories in shared root\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n            const shares: string[] = []\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            if (target === filePath) {\n                                shares.push(userDir.name)\n                            }\n                        } catch (e) {\n                            // Not a symlink or other error, ignore\n                        }\n                    }\n                } catch (e) {\n                    // Cannot read user dir, ignore\n                }\n            }\n            return shares\n        } catch (e) {\n            // Shared root likely doesn't exist yet\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting shares:\", error)\n        return []\n    }\n}\n\nexport async function getSharedFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const currentUser = os.userInfo().username\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared', currentUser)\n\n        await fs.mkdir(sharedRoot, { recursive: true })\n\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(sharedRoot, relativePath)\n\n        // Security check\n        if (!fullPath.startsWith(sharedRoot)) {\n            throw new Error(\"Access denied: Cannot traverse above shared root\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n\n                // For shared files, we might want to know who shared it (the link owner usually)\n                // but lstat on the link itself in the parent dir might be needed if we want link info.\n                // For now, presenting the target file info is fine.\n\n                // Determine type extension logic same as getFiles\n                if (!entry.isDirectory()) {\n                    if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                    else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                    else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n                }\n\n                const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                return {\n                    id: entryPath,\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}`\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error getting shared files:\", error)\n        return []\n    }\n}\n\nexport interface SharedFileItem extends FileItem {\n    sharedWith: { username: string, linkPath: string }[]\n}\n\nexport async function getOutgoingShares(): Promise<SharedFileItem[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const myHome = os.homedir()\n\n        // Map of sourcePath -> { sharedWith: [] }\n        const shareMap = new Map<string, { username: string, linkPath: string }[]>()\n\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            // Check if target is inside my home directory (or belongs to me)\n                            // Ideally check if I own the target file\n                            if (target.startsWith(myHome)) {\n                                if (!shareMap.has(target)) {\n                                    shareMap.set(target, [])\n                                }\n                                shareMap.get(target)?.push({ username: userDir.name, linkPath })\n                            }\n                        } catch (e) {\n                            // Not a symlink\n                        }\n                    }\n                } catch (e) {\n                    // Ignore\n                }\n            }\n\n            // Convert map to SharedFileItem list\n            const results: SharedFileItem[] = []\n            for (const [filePath, shares] of shareMap.entries()) {\n                try {\n                    const stats = await fs.stat(filePath)\n                    const name = path.basename(filePath)\n\n                    let type: FileItem['type'] = 'file'\n                    if (stats.isDirectory()) type = 'folder'\n                    else if (name.endsWith('.sh') || name.endsWith('.py')) type = 'script'\n                    else if (name.endsWith('.csv') || name.endsWith('.json')) type = 'data'\n                    else if (name.endsWith('.zip') || name.endsWith('.tar') || name.endsWith('.gz')) type = 'archive'\n\n                    const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                    results.push({\n                        id: filePath,\n                        name: name,\n                        type: type,\n                        path: filePath,\n                        owner: await getUsername(stats.uid),\n                        group: String(stats.gid),\n                        modifiedAt: stats.mtime.toISOString(),\n                        sizeBytes: stats.size,\n                        permissions: `0${perms}`,\n                        sharedWith: shares\n                    })\n                } catch (e) {\n                    // File might have been deleted but link exists\n                }\n            }\n            return results\n\n        } catch (e) {\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting outgoing shares:\", error)\n        return []\n    }\n}\n\nexport async function unshareFile(targetUsername: string, fileName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const sharedLinkPath = path.join(os.homedir(), 'hpc_shared', targetUsername, fileName)\n        await fs.unlink(sharedLinkPath)\n        return { success: true, message: `Unshared ${fileName} with ${targetUsername}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to unshare\" }\n    }\n}\n\nexport async function changePermissions(filePath: string, mode: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.chmod(filePath, mode)\n        return { success: true, message: `Updated permissions for ${path.basename(filePath)}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to change permissions\" }\n    }\n}\n\nexport async function uploadFile(formData: FormData): Promise<{ success: boolean, message: string }> {\n    try {\n        const file = formData.get('file') as File\n        const currentPathSegments = JSON.parse(formData.get('pathSegments') as string)\n\n        if (!file) {\n            throw new Error(\"No file provided\")\n        }\n\n        const buffer = Buffer.from(await file.arrayBuffer())\n        const relativePath = path.join(...currentPathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.writeFile(path.join(targetDir, file.name), buffer)\n        return { success: true, message: `Uploaded ${file.name}` }\n    } catch (error: any) {\n        console.error(\"Upload error:\", error)\n        return { success: false, message: error.message || \"Upload failed\" }\n    }\n}\n\nexport async function createFolder(pathSegments: string[], folderName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const relativePath = path.join(...pathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath, folderName)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.mkdir(targetDir)\n        return { success: true, message: `Created folder ${folderName}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to create folder\" }\n    }\n}\n\nexport async function deleteItem(itemPath: string): Promise<{ success: boolean, message: string }> {\n    return moveToTrash(itemPath) // Default to trash\n}\n\nconst TRASH_PATH = path.join(os.homedir(), '.hpc_trash')\n\nexport async function moveToTrash(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n\n        const timestamp = Date.now()\n        const trashName = `${path.basename(itemPath)}_${timestamp}`\n        const trashPath = path.join(TRASH_PATH, trashName)\n\n        // Store metadata for restoration\n        const metadata = {\n            originalPath: itemPath,\n            deletedAt: new Date().toISOString()\n        }\n        await fs.writeFile(`${trashPath}.meta`, JSON.stringify(metadata))\n\n        await fs.rename(itemPath, trashPath)\n        return { success: true, message: `Moved to trash` }\n    } catch (error: any) {\n        console.error(\"Trash error:\", error)\n        return { success: false, message: error.message || \"Failed to move to trash\" }\n    }\n}\n\nexport async function getTrashFiles(): Promise<FileItem[]> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n        const entries = await fs.readdir(TRASH_PATH)\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            if (entry.endsWith('.meta')) return null\n\n            try {\n                const entryPath = path.join(TRASH_PATH, entry)\n                const stats = await fs.stat(entryPath)\n                const name = entry.split('_').slice(0, -1).join('_') || entry // Attempt to recover name\n\n                return {\n                    id: entryPath,\n                    name: name,\n                    type: stats.isDirectory() ? 'folder' : 'file',\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: '000' // Trash items usually treated differently\n                } as FileItem\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (e) {\n        return []\n    }\n}\n\nexport async function restoreFromTrash(trashPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        // Try to read metadata\n        const metaPath = `${trashPath}.meta`\n        let targetPath = path.join(os.homedir(), path.basename(trashPath).split('_').slice(0, -1).join('_'))\n\n        try {\n            const metaContent = await fs.readFile(metaPath, 'utf-8')\n            const metadata = JSON.parse(metaContent)\n            targetPath = metadata.originalPath\n        } catch (e) {\n            // Fallback used above\n        }\n\n        // Check if target exists\n        try {\n            await fs.access(targetPath)\n            return { success: false, message: \"Original location occupied. Rename or move file first.\" }\n        } catch (e) {\n            // Good, target doesn't exist\n        }\n\n        await fs.rename(trashPath, targetPath)\n        try { await fs.unlink(metaPath) } catch (e) { } // Delete meta if exists\n\n        return { success: true, message: \"Restored successfully\" }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to restore\" }\n    }\n}\n\nexport async function permanentDelete(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        if (!itemPath.startsWith(TRASH_PATH)) {\n            throw new Error(\"Access denied: Can only permanent delete from trash\")\n        }\n        await fs.rm(itemPath, { recursive: true, force: true })\n        try { await fs.unlink(`${itemPath}.meta`) } catch (e) { }\n        return { success: true, message: \"Permanently deleted\" }\n    } catch (error: any) {\n        return { success: false, message: error.message }\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAuFsB,YAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 2509, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/app/actions.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs/promises'\nimport path from 'path'\nimport os from 'os'\nimport { FileItem } from '@/lib/mockData'\n\nconst BASE_PATH = os.homedir()\n\nexport async function getFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(BASE_PATH, relativePath)\n\n        // Security check: Ensure we don't escape home directory (basic check)\n        if (!fullPath.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied: Cannot traverse above home directory\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n                else if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n\n                // Permission string simulation (Node fs doesn't give \"rwx\" string directly easily across platforms, \n                // but we can approximate from mode)\n                const perms = (stats.mode & parseInt('777', 8)).toString(8) // simple octal\n\n                return {\n                    id: entryPath, // Use path as ID\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}` // Mocking the rwx string is complex, showing octal for now\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error reading directory:\", error)\n        return []\n    }\n}\n\nimport { exec } from 'child_process'\nimport util from 'util'\n\nconst execAsync = util.promisify(exec)\n\nconst usernameCache = new Map<number, string>()\n\nasync function getUsername(uid: number): Promise<string> {\n    if (usernameCache.has(uid)) return usernameCache.get(uid)!\n    try {\n        const { stdout } = await execAsync(`id -nu ${uid}`)\n        const name = stdout.trim()\n        usernameCache.set(uid, name)\n        return name\n    } catch (e) {\n        return String(uid)\n    }\n}\n\nasync function userExists(username: string): Promise<boolean> {\n    try {\n        await execAsync(`id -u ${username}`)\n        return true\n    } catch (error) {\n        return false\n    }\n}\n\nexport async function shareFile(sourcePath: string, targetUsername: string): Promise<{ success: boolean, message: string }> {\n    // Validate target user exists\n    if (!await userExists(targetUsername)) {\n        return { success: false, message: `User '${targetUsername}' does not exist on this system.` }\n    }\n\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const targetUserDir = path.join(sharedRoot, targetUsername)\n\n        // Ensure shared directories exist\n        await fs.mkdir(targetUserDir, { recursive: true })\n\n        const sourceName = path.basename(sourcePath)\n        const destPath = path.join(targetUserDir, sourceName)\n\n        try {\n            await fs.symlink(sourcePath, destPath)\n            return { success: true, message: `Successfully shared with ${targetUsername}` }\n        } catch (e: any) {\n            if (e.code === 'EEXIST') {\n                return { success: false, message: `Already shared with ${targetUsername}` }\n            }\n            throw e\n        }\n    } catch (error: any) {\n        console.error(\"Error sharing file:\", error)\n        return { success: false, message: error.message || \"Failed to share file\" }\n    }\n}\n\nexport async function getFileShares(filePath: string): Promise<string[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n\n        // Scan all user directories in shared root\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n            const shares: string[] = []\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            if (target === filePath) {\n                                shares.push(userDir.name)\n                            }\n                        } catch (e) {\n                            // Not a symlink or other error, ignore\n                        }\n                    }\n                } catch (e) {\n                    // Cannot read user dir, ignore\n                }\n            }\n            return shares\n        } catch (e) {\n            // Shared root likely doesn't exist yet\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting shares:\", error)\n        return []\n    }\n}\n\nexport async function getSharedFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const currentUser = os.userInfo().username\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared', currentUser)\n\n        await fs.mkdir(sharedRoot, { recursive: true })\n\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(sharedRoot, relativePath)\n\n        // Security check\n        if (!fullPath.startsWith(sharedRoot)) {\n            throw new Error(\"Access denied: Cannot traverse above shared root\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n\n                // For shared files, we might want to know who shared it (the link owner usually)\n                // but lstat on the link itself in the parent dir might be needed if we want link info.\n                // For now, presenting the target file info is fine.\n\n                // Determine type extension logic same as getFiles\n                if (!entry.isDirectory()) {\n                    if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                    else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                    else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n                }\n\n                const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                return {\n                    id: entryPath,\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}`\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error getting shared files:\", error)\n        return []\n    }\n}\n\nexport interface SharedFileItem extends FileItem {\n    sharedWith: { username: string, linkPath: string }[]\n}\n\nexport async function getOutgoingShares(): Promise<SharedFileItem[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const myHome = os.homedir()\n\n        // Map of sourcePath -> { sharedWith: [] }\n        const shareMap = new Map<string, { username: string, linkPath: string }[]>()\n\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            // Check if target is inside my home directory (or belongs to me)\n                            // Ideally check if I own the target file\n                            if (target.startsWith(myHome)) {\n                                if (!shareMap.has(target)) {\n                                    shareMap.set(target, [])\n                                }\n                                shareMap.get(target)?.push({ username: userDir.name, linkPath })\n                            }\n                        } catch (e) {\n                            // Not a symlink\n                        }\n                    }\n                } catch (e) {\n                    // Ignore\n                }\n            }\n\n            // Convert map to SharedFileItem list\n            const results: SharedFileItem[] = []\n            for (const [filePath, shares] of shareMap.entries()) {\n                try {\n                    const stats = await fs.stat(filePath)\n                    const name = path.basename(filePath)\n\n                    let type: FileItem['type'] = 'file'\n                    if (stats.isDirectory()) type = 'folder'\n                    else if (name.endsWith('.sh') || name.endsWith('.py')) type = 'script'\n                    else if (name.endsWith('.csv') || name.endsWith('.json')) type = 'data'\n                    else if (name.endsWith('.zip') || name.endsWith('.tar') || name.endsWith('.gz')) type = 'archive'\n\n                    const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                    results.push({\n                        id: filePath,\n                        name: name,\n                        type: type,\n                        path: filePath,\n                        owner: await getUsername(stats.uid),\n                        group: String(stats.gid),\n                        modifiedAt: stats.mtime.toISOString(),\n                        sizeBytes: stats.size,\n                        permissions: `0${perms}`,\n                        sharedWith: shares\n                    })\n                } catch (e) {\n                    // File might have been deleted but link exists\n                }\n            }\n            return results\n\n        } catch (e) {\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting outgoing shares:\", error)\n        return []\n    }\n}\n\nexport async function unshareFile(targetUsername: string, fileName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const sharedLinkPath = path.join(os.homedir(), 'hpc_shared', targetUsername, fileName)\n        await fs.unlink(sharedLinkPath)\n        return { success: true, message: `Unshared ${fileName} with ${targetUsername}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to unshare\" }\n    }\n}\n\nexport async function changePermissions(filePath: string, mode: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.chmod(filePath, mode)\n        return { success: true, message: `Updated permissions for ${path.basename(filePath)}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to change permissions\" }\n    }\n}\n\nexport async function uploadFile(formData: FormData): Promise<{ success: boolean, message: string }> {\n    try {\n        const file = formData.get('file') as File\n        const currentPathSegments = JSON.parse(formData.get('pathSegments') as string)\n\n        if (!file) {\n            throw new Error(\"No file provided\")\n        }\n\n        const buffer = Buffer.from(await file.arrayBuffer())\n        const relativePath = path.join(...currentPathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.writeFile(path.join(targetDir, file.name), buffer)\n        return { success: true, message: `Uploaded ${file.name}` }\n    } catch (error: any) {\n        console.error(\"Upload error:\", error)\n        return { success: false, message: error.message || \"Upload failed\" }\n    }\n}\n\nexport async function createFolder(pathSegments: string[], folderName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const relativePath = path.join(...pathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath, folderName)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.mkdir(targetDir)\n        return { success: true, message: `Created folder ${folderName}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to create folder\" }\n    }\n}\n\nexport async function deleteItem(itemPath: string): Promise<{ success: boolean, message: string }> {\n    return moveToTrash(itemPath) // Default to trash\n}\n\nconst TRASH_PATH = path.join(os.homedir(), '.hpc_trash')\n\nexport async function moveToTrash(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n\n        const timestamp = Date.now()\n        const trashName = `${path.basename(itemPath)}_${timestamp}`\n        const trashPath = path.join(TRASH_PATH, trashName)\n\n        // Store metadata for restoration\n        const metadata = {\n            originalPath: itemPath,\n            deletedAt: new Date().toISOString()\n        }\n        await fs.writeFile(`${trashPath}.meta`, JSON.stringify(metadata))\n\n        await fs.rename(itemPath, trashPath)\n        return { success: true, message: `Moved to trash` }\n    } catch (error: any) {\n        console.error(\"Trash error:\", error)\n        return { success: false, message: error.message || \"Failed to move to trash\" }\n    }\n}\n\nexport async function getTrashFiles(): Promise<FileItem[]> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n        const entries = await fs.readdir(TRASH_PATH)\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            if (entry.endsWith('.meta')) return null\n\n            try {\n                const entryPath = path.join(TRASH_PATH, entry)\n                const stats = await fs.stat(entryPath)\n                const name = entry.split('_').slice(0, -1).join('_') || entry // Attempt to recover name\n\n                return {\n                    id: entryPath,\n                    name: name,\n                    type: stats.isDirectory() ? 'folder' : 'file',\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: '000' // Trash items usually treated differently\n                } as FileItem\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (e) {\n        return []\n    }\n}\n\nexport async function restoreFromTrash(trashPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        // Try to read metadata\n        const metaPath = `${trashPath}.meta`\n        let targetPath = path.join(os.homedir(), path.basename(trashPath).split('_').slice(0, -1).join('_'))\n\n        try {\n            const metaContent = await fs.readFile(metaPath, 'utf-8')\n            const metadata = JSON.parse(metaContent)\n            targetPath = metadata.originalPath\n        } catch (e) {\n            // Fallback used above\n        }\n\n        // Check if target exists\n        try {\n            await fs.access(targetPath)\n            return { success: false, message: \"Original location occupied. Rename or move file first.\" }\n        } catch (e) {\n            // Good, target doesn't exist\n        }\n\n        await fs.rename(trashPath, targetPath)\n        try { await fs.unlink(metaPath) } catch (e) { } // Delete meta if exists\n\n        return { success: true, message: \"Restored successfully\" }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to restore\" }\n    }\n}\n\nexport async function permanentDelete(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        if (!itemPath.startsWith(TRASH_PATH)) {\n            throw new Error(\"Access denied: Can only permanent delete from trash\")\n        }\n        await fs.rm(itemPath, { recursive: true, force: true })\n        try { await fs.unlink(`${itemPath}.meta`) } catch (e) { }\n        return { success: true, message: \"Permanently deleted\" }\n    } catch (error: any) {\n        return { success: false, message: error.message }\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAgKsB,iBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 2521, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/app/actions.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs/promises'\nimport path from 'path'\nimport os from 'os'\nimport { FileItem } from '@/lib/mockData'\n\nconst BASE_PATH = os.homedir()\n\nexport async function getFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(BASE_PATH, relativePath)\n\n        // Security check: Ensure we don't escape home directory (basic check)\n        if (!fullPath.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied: Cannot traverse above home directory\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n                else if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n\n                // Permission string simulation (Node fs doesn't give \"rwx\" string directly easily across platforms, \n                // but we can approximate from mode)\n                const perms = (stats.mode & parseInt('777', 8)).toString(8) // simple octal\n\n                return {\n                    id: entryPath, // Use path as ID\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}` // Mocking the rwx string is complex, showing octal for now\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error reading directory:\", error)\n        return []\n    }\n}\n\nimport { exec } from 'child_process'\nimport util from 'util'\n\nconst execAsync = util.promisify(exec)\n\nconst usernameCache = new Map<number, string>()\n\nasync function getUsername(uid: number): Promise<string> {\n    if (usernameCache.has(uid)) return usernameCache.get(uid)!\n    try {\n        const { stdout } = await execAsync(`id -nu ${uid}`)\n        const name = stdout.trim()\n        usernameCache.set(uid, name)\n        return name\n    } catch (e) {\n        return String(uid)\n    }\n}\n\nasync function userExists(username: string): Promise<boolean> {\n    try {\n        await execAsync(`id -u ${username}`)\n        return true\n    } catch (error) {\n        return false\n    }\n}\n\nexport async function shareFile(sourcePath: string, targetUsername: string): Promise<{ success: boolean, message: string }> {\n    // Validate target user exists\n    if (!await userExists(targetUsername)) {\n        return { success: false, message: `User '${targetUsername}' does not exist on this system.` }\n    }\n\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const targetUserDir = path.join(sharedRoot, targetUsername)\n\n        // Ensure shared directories exist\n        await fs.mkdir(targetUserDir, { recursive: true })\n\n        const sourceName = path.basename(sourcePath)\n        const destPath = path.join(targetUserDir, sourceName)\n\n        try {\n            await fs.symlink(sourcePath, destPath)\n            return { success: true, message: `Successfully shared with ${targetUsername}` }\n        } catch (e: any) {\n            if (e.code === 'EEXIST') {\n                return { success: false, message: `Already shared with ${targetUsername}` }\n            }\n            throw e\n        }\n    } catch (error: any) {\n        console.error(\"Error sharing file:\", error)\n        return { success: false, message: error.message || \"Failed to share file\" }\n    }\n}\n\nexport async function getFileShares(filePath: string): Promise<string[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n\n        // Scan all user directories in shared root\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n            const shares: string[] = []\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            if (target === filePath) {\n                                shares.push(userDir.name)\n                            }\n                        } catch (e) {\n                            // Not a symlink or other error, ignore\n                        }\n                    }\n                } catch (e) {\n                    // Cannot read user dir, ignore\n                }\n            }\n            return shares\n        } catch (e) {\n            // Shared root likely doesn't exist yet\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting shares:\", error)\n        return []\n    }\n}\n\nexport async function getSharedFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const currentUser = os.userInfo().username\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared', currentUser)\n\n        await fs.mkdir(sharedRoot, { recursive: true })\n\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(sharedRoot, relativePath)\n\n        // Security check\n        if (!fullPath.startsWith(sharedRoot)) {\n            throw new Error(\"Access denied: Cannot traverse above shared root\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n\n                // For shared files, we might want to know who shared it (the link owner usually)\n                // but lstat on the link itself in the parent dir might be needed if we want link info.\n                // For now, presenting the target file info is fine.\n\n                // Determine type extension logic same as getFiles\n                if (!entry.isDirectory()) {\n                    if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                    else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                    else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n                }\n\n                const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                return {\n                    id: entryPath,\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}`\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error getting shared files:\", error)\n        return []\n    }\n}\n\nexport interface SharedFileItem extends FileItem {\n    sharedWith: { username: string, linkPath: string }[]\n}\n\nexport async function getOutgoingShares(): Promise<SharedFileItem[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const myHome = os.homedir()\n\n        // Map of sourcePath -> { sharedWith: [] }\n        const shareMap = new Map<string, { username: string, linkPath: string }[]>()\n\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            // Check if target is inside my home directory (or belongs to me)\n                            // Ideally check if I own the target file\n                            if (target.startsWith(myHome)) {\n                                if (!shareMap.has(target)) {\n                                    shareMap.set(target, [])\n                                }\n                                shareMap.get(target)?.push({ username: userDir.name, linkPath })\n                            }\n                        } catch (e) {\n                            // Not a symlink\n                        }\n                    }\n                } catch (e) {\n                    // Ignore\n                }\n            }\n\n            // Convert map to SharedFileItem list\n            const results: SharedFileItem[] = []\n            for (const [filePath, shares] of shareMap.entries()) {\n                try {\n                    const stats = await fs.stat(filePath)\n                    const name = path.basename(filePath)\n\n                    let type: FileItem['type'] = 'file'\n                    if (stats.isDirectory()) type = 'folder'\n                    else if (name.endsWith('.sh') || name.endsWith('.py')) type = 'script'\n                    else if (name.endsWith('.csv') || name.endsWith('.json')) type = 'data'\n                    else if (name.endsWith('.zip') || name.endsWith('.tar') || name.endsWith('.gz')) type = 'archive'\n\n                    const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                    results.push({\n                        id: filePath,\n                        name: name,\n                        type: type,\n                        path: filePath,\n                        owner: await getUsername(stats.uid),\n                        group: String(stats.gid),\n                        modifiedAt: stats.mtime.toISOString(),\n                        sizeBytes: stats.size,\n                        permissions: `0${perms}`,\n                        sharedWith: shares\n                    })\n                } catch (e) {\n                    // File might have been deleted but link exists\n                }\n            }\n            return results\n\n        } catch (e) {\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting outgoing shares:\", error)\n        return []\n    }\n}\n\nexport async function unshareFile(targetUsername: string, fileName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const sharedLinkPath = path.join(os.homedir(), 'hpc_shared', targetUsername, fileName)\n        await fs.unlink(sharedLinkPath)\n        return { success: true, message: `Unshared ${fileName} with ${targetUsername}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to unshare\" }\n    }\n}\n\nexport async function changePermissions(filePath: string, mode: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.chmod(filePath, mode)\n        return { success: true, message: `Updated permissions for ${path.basename(filePath)}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to change permissions\" }\n    }\n}\n\nexport async function uploadFile(formData: FormData): Promise<{ success: boolean, message: string }> {\n    try {\n        const file = formData.get('file') as File\n        const currentPathSegments = JSON.parse(formData.get('pathSegments') as string)\n\n        if (!file) {\n            throw new Error(\"No file provided\")\n        }\n\n        const buffer = Buffer.from(await file.arrayBuffer())\n        const relativePath = path.join(...currentPathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.writeFile(path.join(targetDir, file.name), buffer)\n        return { success: true, message: `Uploaded ${file.name}` }\n    } catch (error: any) {\n        console.error(\"Upload error:\", error)\n        return { success: false, message: error.message || \"Upload failed\" }\n    }\n}\n\nexport async function createFolder(pathSegments: string[], folderName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const relativePath = path.join(...pathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath, folderName)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.mkdir(targetDir)\n        return { success: true, message: `Created folder ${folderName}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to create folder\" }\n    }\n}\n\nexport async function deleteItem(itemPath: string): Promise<{ success: boolean, message: string }> {\n    return moveToTrash(itemPath) // Default to trash\n}\n\nconst TRASH_PATH = path.join(os.homedir(), '.hpc_trash')\n\nexport async function moveToTrash(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n\n        const timestamp = Date.now()\n        const trashName = `${path.basename(itemPath)}_${timestamp}`\n        const trashPath = path.join(TRASH_PATH, trashName)\n\n        // Store metadata for restoration\n        const metadata = {\n            originalPath: itemPath,\n            deletedAt: new Date().toISOString()\n        }\n        await fs.writeFile(`${trashPath}.meta`, JSON.stringify(metadata))\n\n        await fs.rename(itemPath, trashPath)\n        return { success: true, message: `Moved to trash` }\n    } catch (error: any) {\n        console.error(\"Trash error:\", error)\n        return { success: false, message: error.message || \"Failed to move to trash\" }\n    }\n}\n\nexport async function getTrashFiles(): Promise<FileItem[]> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n        const entries = await fs.readdir(TRASH_PATH)\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            if (entry.endsWith('.meta')) return null\n\n            try {\n                const entryPath = path.join(TRASH_PATH, entry)\n                const stats = await fs.stat(entryPath)\n                const name = entry.split('_').slice(0, -1).join('_') || entry // Attempt to recover name\n\n                return {\n                    id: entryPath,\n                    name: name,\n                    type: stats.isDirectory() ? 'folder' : 'file',\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: '000' // Trash items usually treated differently\n                } as FileItem\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (e) {\n        return []\n    }\n}\n\nexport async function restoreFromTrash(trashPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        // Try to read metadata\n        const metaPath = `${trashPath}.meta`\n        let targetPath = path.join(os.homedir(), path.basename(trashPath).split('_').slice(0, -1).join('_'))\n\n        try {\n            const metaContent = await fs.readFile(metaPath, 'utf-8')\n            const metadata = JSON.parse(metaContent)\n            targetPath = metadata.originalPath\n        } catch (e) {\n            // Fallback used above\n        }\n\n        // Check if target exists\n        try {\n            await fs.access(targetPath)\n            return { success: false, message: \"Original location occupied. Rename or move file first.\" }\n        } catch (e) {\n            // Good, target doesn't exist\n        }\n\n        await fs.rename(trashPath, targetPath)\n        try { await fs.unlink(metaPath) } catch (e) { } // Delete meta if exists\n\n        return { success: true, message: \"Restored successfully\" }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to restore\" }\n    }\n}\n\nexport async function permanentDelete(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        if (!itemPath.startsWith(TRASH_PATH)) {\n            throw new Error(\"Access denied: Can only permanent delete from trash\")\n        }\n        await fs.rm(itemPath, { recursive: true, force: true })\n        try { await fs.unlink(`${itemPath}.meta`) } catch (e) { }\n        return { success: true, message: \"Permanently deleted\" }\n    } catch (error: any) {\n        return { success: false, message: error.message }\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAiOsB,oBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 2533, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/app/actions.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs/promises'\nimport path from 'path'\nimport os from 'os'\nimport { FileItem } from '@/lib/mockData'\n\nconst BASE_PATH = os.homedir()\n\nexport async function getFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(BASE_PATH, relativePath)\n\n        // Security check: Ensure we don't escape home directory (basic check)\n        if (!fullPath.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied: Cannot traverse above home directory\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n                else if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n\n                // Permission string simulation (Node fs doesn't give \"rwx\" string directly easily across platforms, \n                // but we can approximate from mode)\n                const perms = (stats.mode & parseInt('777', 8)).toString(8) // simple octal\n\n                return {\n                    id: entryPath, // Use path as ID\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}` // Mocking the rwx string is complex, showing octal for now\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error reading directory:\", error)\n        return []\n    }\n}\n\nimport { exec } from 'child_process'\nimport util from 'util'\n\nconst execAsync = util.promisify(exec)\n\nconst usernameCache = new Map<number, string>()\n\nasync function getUsername(uid: number): Promise<string> {\n    if (usernameCache.has(uid)) return usernameCache.get(uid)!\n    try {\n        const { stdout } = await execAsync(`id -nu ${uid}`)\n        const name = stdout.trim()\n        usernameCache.set(uid, name)\n        return name\n    } catch (e) {\n        return String(uid)\n    }\n}\n\nasync function userExists(username: string): Promise<boolean> {\n    try {\n        await execAsync(`id -u ${username}`)\n        return true\n    } catch (error) {\n        return false\n    }\n}\n\nexport async function shareFile(sourcePath: string, targetUsername: string): Promise<{ success: boolean, message: string }> {\n    // Validate target user exists\n    if (!await userExists(targetUsername)) {\n        return { success: false, message: `User '${targetUsername}' does not exist on this system.` }\n    }\n\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const targetUserDir = path.join(sharedRoot, targetUsername)\n\n        // Ensure shared directories exist\n        await fs.mkdir(targetUserDir, { recursive: true })\n\n        const sourceName = path.basename(sourcePath)\n        const destPath = path.join(targetUserDir, sourceName)\n\n        try {\n            await fs.symlink(sourcePath, destPath)\n            return { success: true, message: `Successfully shared with ${targetUsername}` }\n        } catch (e: any) {\n            if (e.code === 'EEXIST') {\n                return { success: false, message: `Already shared with ${targetUsername}` }\n            }\n            throw e\n        }\n    } catch (error: any) {\n        console.error(\"Error sharing file:\", error)\n        return { success: false, message: error.message || \"Failed to share file\" }\n    }\n}\n\nexport async function getFileShares(filePath: string): Promise<string[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n\n        // Scan all user directories in shared root\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n            const shares: string[] = []\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            if (target === filePath) {\n                                shares.push(userDir.name)\n                            }\n                        } catch (e) {\n                            // Not a symlink or other error, ignore\n                        }\n                    }\n                } catch (e) {\n                    // Cannot read user dir, ignore\n                }\n            }\n            return shares\n        } catch (e) {\n            // Shared root likely doesn't exist yet\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting shares:\", error)\n        return []\n    }\n}\n\nexport async function getSharedFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const currentUser = os.userInfo().username\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared', currentUser)\n\n        await fs.mkdir(sharedRoot, { recursive: true })\n\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(sharedRoot, relativePath)\n\n        // Security check\n        if (!fullPath.startsWith(sharedRoot)) {\n            throw new Error(\"Access denied: Cannot traverse above shared root\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n\n                // For shared files, we might want to know who shared it (the link owner usually)\n                // but lstat on the link itself in the parent dir might be needed if we want link info.\n                // For now, presenting the target file info is fine.\n\n                // Determine type extension logic same as getFiles\n                if (!entry.isDirectory()) {\n                    if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                    else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                    else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n                }\n\n                const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                return {\n                    id: entryPath,\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}`\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error getting shared files:\", error)\n        return []\n    }\n}\n\nexport interface SharedFileItem extends FileItem {\n    sharedWith: { username: string, linkPath: string }[]\n}\n\nexport async function getOutgoingShares(): Promise<SharedFileItem[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const myHome = os.homedir()\n\n        // Map of sourcePath -> { sharedWith: [] }\n        const shareMap = new Map<string, { username: string, linkPath: string }[]>()\n\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            // Check if target is inside my home directory (or belongs to me)\n                            // Ideally check if I own the target file\n                            if (target.startsWith(myHome)) {\n                                if (!shareMap.has(target)) {\n                                    shareMap.set(target, [])\n                                }\n                                shareMap.get(target)?.push({ username: userDir.name, linkPath })\n                            }\n                        } catch (e) {\n                            // Not a symlink\n                        }\n                    }\n                } catch (e) {\n                    // Ignore\n                }\n            }\n\n            // Convert map to SharedFileItem list\n            const results: SharedFileItem[] = []\n            for (const [filePath, shares] of shareMap.entries()) {\n                try {\n                    const stats = await fs.stat(filePath)\n                    const name = path.basename(filePath)\n\n                    let type: FileItem['type'] = 'file'\n                    if (stats.isDirectory()) type = 'folder'\n                    else if (name.endsWith('.sh') || name.endsWith('.py')) type = 'script'\n                    else if (name.endsWith('.csv') || name.endsWith('.json')) type = 'data'\n                    else if (name.endsWith('.zip') || name.endsWith('.tar') || name.endsWith('.gz')) type = 'archive'\n\n                    const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                    results.push({\n                        id: filePath,\n                        name: name,\n                        type: type,\n                        path: filePath,\n                        owner: await getUsername(stats.uid),\n                        group: String(stats.gid),\n                        modifiedAt: stats.mtime.toISOString(),\n                        sizeBytes: stats.size,\n                        permissions: `0${perms}`,\n                        sharedWith: shares\n                    })\n                } catch (e) {\n                    // File might have been deleted but link exists\n                }\n            }\n            return results\n\n        } catch (e) {\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting outgoing shares:\", error)\n        return []\n    }\n}\n\nexport async function unshareFile(targetUsername: string, fileName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const sharedLinkPath = path.join(os.homedir(), 'hpc_shared', targetUsername, fileName)\n        await fs.unlink(sharedLinkPath)\n        return { success: true, message: `Unshared ${fileName} with ${targetUsername}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to unshare\" }\n    }\n}\n\nexport async function changePermissions(filePath: string, mode: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.chmod(filePath, mode)\n        return { success: true, message: `Updated permissions for ${path.basename(filePath)}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to change permissions\" }\n    }\n}\n\nexport async function uploadFile(formData: FormData): Promise<{ success: boolean, message: string }> {\n    try {\n        const file = formData.get('file') as File\n        const currentPathSegments = JSON.parse(formData.get('pathSegments') as string)\n\n        if (!file) {\n            throw new Error(\"No file provided\")\n        }\n\n        const buffer = Buffer.from(await file.arrayBuffer())\n        const relativePath = path.join(...currentPathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.writeFile(path.join(targetDir, file.name), buffer)\n        return { success: true, message: `Uploaded ${file.name}` }\n    } catch (error: any) {\n        console.error(\"Upload error:\", error)\n        return { success: false, message: error.message || \"Upload failed\" }\n    }\n}\n\nexport async function createFolder(pathSegments: string[], folderName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const relativePath = path.join(...pathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath, folderName)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.mkdir(targetDir)\n        return { success: true, message: `Created folder ${folderName}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to create folder\" }\n    }\n}\n\nexport async function deleteItem(itemPath: string): Promise<{ success: boolean, message: string }> {\n    return moveToTrash(itemPath) // Default to trash\n}\n\nconst TRASH_PATH = path.join(os.homedir(), '.hpc_trash')\n\nexport async function moveToTrash(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n\n        const timestamp = Date.now()\n        const trashName = `${path.basename(itemPath)}_${timestamp}`\n        const trashPath = path.join(TRASH_PATH, trashName)\n\n        // Store metadata for restoration\n        const metadata = {\n            originalPath: itemPath,\n            deletedAt: new Date().toISOString()\n        }\n        await fs.writeFile(`${trashPath}.meta`, JSON.stringify(metadata))\n\n        await fs.rename(itemPath, trashPath)\n        return { success: true, message: `Moved to trash` }\n    } catch (error: any) {\n        console.error(\"Trash error:\", error)\n        return { success: false, message: error.message || \"Failed to move to trash\" }\n    }\n}\n\nexport async function getTrashFiles(): Promise<FileItem[]> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n        const entries = await fs.readdir(TRASH_PATH)\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            if (entry.endsWith('.meta')) return null\n\n            try {\n                const entryPath = path.join(TRASH_PATH, entry)\n                const stats = await fs.stat(entryPath)\n                const name = entry.split('_').slice(0, -1).join('_') || entry // Attempt to recover name\n\n                return {\n                    id: entryPath,\n                    name: name,\n                    type: stats.isDirectory() ? 'folder' : 'file',\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: '000' // Trash items usually treated differently\n                } as FileItem\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (e) {\n        return []\n    }\n}\n\nexport async function restoreFromTrash(trashPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        // Try to read metadata\n        const metaPath = `${trashPath}.meta`\n        let targetPath = path.join(os.homedir(), path.basename(trashPath).split('_').slice(0, -1).join('_'))\n\n        try {\n            const metaContent = await fs.readFile(metaPath, 'utf-8')\n            const metadata = JSON.parse(metaContent)\n            targetPath = metadata.originalPath\n        } catch (e) {\n            // Fallback used above\n        }\n\n        // Check if target exists\n        try {\n            await fs.access(targetPath)\n            return { success: false, message: \"Original location occupied. Rename or move file first.\" }\n        } catch (e) {\n            // Good, target doesn't exist\n        }\n\n        await fs.rename(trashPath, targetPath)\n        try { await fs.unlink(metaPath) } catch (e) { } // Delete meta if exists\n\n        return { success: true, message: \"Restored successfully\" }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to restore\" }\n    }\n}\n\nexport async function permanentDelete(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        if (!itemPath.startsWith(TRASH_PATH)) {\n            throw new Error(\"Access denied: Can only permanent delete from trash\")\n        }\n        await fs.rm(itemPath, { recursive: true, force: true })\n        try { await fs.unlink(`${itemPath}.meta`) } catch (e) { }\n        return { success: true, message: \"Permanently deleted\" }\n    } catch (error: any) {\n        return { success: false, message: error.message }\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAkTsB,cAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 2545, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/app/actions.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs/promises'\nimport path from 'path'\nimport os from 'os'\nimport { FileItem } from '@/lib/mockData'\n\nconst BASE_PATH = os.homedir()\n\nexport async function getFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(BASE_PATH, relativePath)\n\n        // Security check: Ensure we don't escape home directory (basic check)\n        if (!fullPath.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied: Cannot traverse above home directory\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n                else if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n\n                // Permission string simulation (Node fs doesn't give \"rwx\" string directly easily across platforms, \n                // but we can approximate from mode)\n                const perms = (stats.mode & parseInt('777', 8)).toString(8) // simple octal\n\n                return {\n                    id: entryPath, // Use path as ID\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}` // Mocking the rwx string is complex, showing octal for now\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error reading directory:\", error)\n        return []\n    }\n}\n\nimport { exec } from 'child_process'\nimport util from 'util'\n\nconst execAsync = util.promisify(exec)\n\nconst usernameCache = new Map<number, string>()\n\nasync function getUsername(uid: number): Promise<string> {\n    if (usernameCache.has(uid)) return usernameCache.get(uid)!\n    try {\n        const { stdout } = await execAsync(`id -nu ${uid}`)\n        const name = stdout.trim()\n        usernameCache.set(uid, name)\n        return name\n    } catch (e) {\n        return String(uid)\n    }\n}\n\nasync function userExists(username: string): Promise<boolean> {\n    try {\n        await execAsync(`id -u ${username}`)\n        return true\n    } catch (error) {\n        return false\n    }\n}\n\nexport async function shareFile(sourcePath: string, targetUsername: string): Promise<{ success: boolean, message: string }> {\n    // Validate target user exists\n    if (!await userExists(targetUsername)) {\n        return { success: false, message: `User '${targetUsername}' does not exist on this system.` }\n    }\n\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const targetUserDir = path.join(sharedRoot, targetUsername)\n\n        // Ensure shared directories exist\n        await fs.mkdir(targetUserDir, { recursive: true })\n\n        const sourceName = path.basename(sourcePath)\n        const destPath = path.join(targetUserDir, sourceName)\n\n        try {\n            await fs.symlink(sourcePath, destPath)\n            return { success: true, message: `Successfully shared with ${targetUsername}` }\n        } catch (e: any) {\n            if (e.code === 'EEXIST') {\n                return { success: false, message: `Already shared with ${targetUsername}` }\n            }\n            throw e\n        }\n    } catch (error: any) {\n        console.error(\"Error sharing file:\", error)\n        return { success: false, message: error.message || \"Failed to share file\" }\n    }\n}\n\nexport async function getFileShares(filePath: string): Promise<string[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n\n        // Scan all user directories in shared root\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n            const shares: string[] = []\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            if (target === filePath) {\n                                shares.push(userDir.name)\n                            }\n                        } catch (e) {\n                            // Not a symlink or other error, ignore\n                        }\n                    }\n                } catch (e) {\n                    // Cannot read user dir, ignore\n                }\n            }\n            return shares\n        } catch (e) {\n            // Shared root likely doesn't exist yet\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting shares:\", error)\n        return []\n    }\n}\n\nexport async function getSharedFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const currentUser = os.userInfo().username\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared', currentUser)\n\n        await fs.mkdir(sharedRoot, { recursive: true })\n\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(sharedRoot, relativePath)\n\n        // Security check\n        if (!fullPath.startsWith(sharedRoot)) {\n            throw new Error(\"Access denied: Cannot traverse above shared root\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n\n                // For shared files, we might want to know who shared it (the link owner usually)\n                // but lstat on the link itself in the parent dir might be needed if we want link info.\n                // For now, presenting the target file info is fine.\n\n                // Determine type extension logic same as getFiles\n                if (!entry.isDirectory()) {\n                    if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                    else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                    else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n                }\n\n                const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                return {\n                    id: entryPath,\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}`\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error getting shared files:\", error)\n        return []\n    }\n}\n\nexport interface SharedFileItem extends FileItem {\n    sharedWith: { username: string, linkPath: string }[]\n}\n\nexport async function getOutgoingShares(): Promise<SharedFileItem[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const myHome = os.homedir()\n\n        // Map of sourcePath -> { sharedWith: [] }\n        const shareMap = new Map<string, { username: string, linkPath: string }[]>()\n\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            // Check if target is inside my home directory (or belongs to me)\n                            // Ideally check if I own the target file\n                            if (target.startsWith(myHome)) {\n                                if (!shareMap.has(target)) {\n                                    shareMap.set(target, [])\n                                }\n                                shareMap.get(target)?.push({ username: userDir.name, linkPath })\n                            }\n                        } catch (e) {\n                            // Not a symlink\n                        }\n                    }\n                } catch (e) {\n                    // Ignore\n                }\n            }\n\n            // Convert map to SharedFileItem list\n            const results: SharedFileItem[] = []\n            for (const [filePath, shares] of shareMap.entries()) {\n                try {\n                    const stats = await fs.stat(filePath)\n                    const name = path.basename(filePath)\n\n                    let type: FileItem['type'] = 'file'\n                    if (stats.isDirectory()) type = 'folder'\n                    else if (name.endsWith('.sh') || name.endsWith('.py')) type = 'script'\n                    else if (name.endsWith('.csv') || name.endsWith('.json')) type = 'data'\n                    else if (name.endsWith('.zip') || name.endsWith('.tar') || name.endsWith('.gz')) type = 'archive'\n\n                    const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                    results.push({\n                        id: filePath,\n                        name: name,\n                        type: type,\n                        path: filePath,\n                        owner: await getUsername(stats.uid),\n                        group: String(stats.gid),\n                        modifiedAt: stats.mtime.toISOString(),\n                        sizeBytes: stats.size,\n                        permissions: `0${perms}`,\n                        sharedWith: shares\n                    })\n                } catch (e) {\n                    // File might have been deleted but link exists\n                }\n            }\n            return results\n\n        } catch (e) {\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting outgoing shares:\", error)\n        return []\n    }\n}\n\nexport async function unshareFile(targetUsername: string, fileName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const sharedLinkPath = path.join(os.homedir(), 'hpc_shared', targetUsername, fileName)\n        await fs.unlink(sharedLinkPath)\n        return { success: true, message: `Unshared ${fileName} with ${targetUsername}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to unshare\" }\n    }\n}\n\nexport async function changePermissions(filePath: string, mode: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.chmod(filePath, mode)\n        return { success: true, message: `Updated permissions for ${path.basename(filePath)}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to change permissions\" }\n    }\n}\n\nexport async function uploadFile(formData: FormData): Promise<{ success: boolean, message: string }> {\n    try {\n        const file = formData.get('file') as File\n        const currentPathSegments = JSON.parse(formData.get('pathSegments') as string)\n\n        if (!file) {\n            throw new Error(\"No file provided\")\n        }\n\n        const buffer = Buffer.from(await file.arrayBuffer())\n        const relativePath = path.join(...currentPathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.writeFile(path.join(targetDir, file.name), buffer)\n        return { success: true, message: `Uploaded ${file.name}` }\n    } catch (error: any) {\n        console.error(\"Upload error:\", error)\n        return { success: false, message: error.message || \"Upload failed\" }\n    }\n}\n\nexport async function createFolder(pathSegments: string[], folderName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const relativePath = path.join(...pathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath, folderName)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.mkdir(targetDir)\n        return { success: true, message: `Created folder ${folderName}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to create folder\" }\n    }\n}\n\nexport async function deleteItem(itemPath: string): Promise<{ success: boolean, message: string }> {\n    return moveToTrash(itemPath) // Default to trash\n}\n\nconst TRASH_PATH = path.join(os.homedir(), '.hpc_trash')\n\nexport async function moveToTrash(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n\n        const timestamp = Date.now()\n        const trashName = `${path.basename(itemPath)}_${timestamp}`\n        const trashPath = path.join(TRASH_PATH, trashName)\n\n        // Store metadata for restoration\n        const metadata = {\n            originalPath: itemPath,\n            deletedAt: new Date().toISOString()\n        }\n        await fs.writeFile(`${trashPath}.meta`, JSON.stringify(metadata))\n\n        await fs.rename(itemPath, trashPath)\n        return { success: true, message: `Moved to trash` }\n    } catch (error: any) {\n        console.error(\"Trash error:\", error)\n        return { success: false, message: error.message || \"Failed to move to trash\" }\n    }\n}\n\nexport async function getTrashFiles(): Promise<FileItem[]> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n        const entries = await fs.readdir(TRASH_PATH)\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            if (entry.endsWith('.meta')) return null\n\n            try {\n                const entryPath = path.join(TRASH_PATH, entry)\n                const stats = await fs.stat(entryPath)\n                const name = entry.split('_').slice(0, -1).join('_') || entry // Attempt to recover name\n\n                return {\n                    id: entryPath,\n                    name: name,\n                    type: stats.isDirectory() ? 'folder' : 'file',\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: '000' // Trash items usually treated differently\n                } as FileItem\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (e) {\n        return []\n    }\n}\n\nexport async function restoreFromTrash(trashPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        // Try to read metadata\n        const metaPath = `${trashPath}.meta`\n        let targetPath = path.join(os.homedir(), path.basename(trashPath).split('_').slice(0, -1).join('_'))\n\n        try {\n            const metaContent = await fs.readFile(metaPath, 'utf-8')\n            const metadata = JSON.parse(metaContent)\n            targetPath = metadata.originalPath\n        } catch (e) {\n            // Fallback used above\n        }\n\n        // Check if target exists\n        try {\n            await fs.access(targetPath)\n            return { success: false, message: \"Original location occupied. Rename or move file first.\" }\n        } catch (e) {\n            // Good, target doesn't exist\n        }\n\n        await fs.rename(trashPath, targetPath)\n        try { await fs.unlink(metaPath) } catch (e) { } // Delete meta if exists\n\n        return { success: true, message: \"Restored successfully\" }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to restore\" }\n    }\n}\n\nexport async function permanentDelete(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        if (!itemPath.startsWith(TRASH_PATH)) {\n            throw new Error(\"Access denied: Can only permanent delete from trash\")\n        }\n        await fs.rm(itemPath, { recursive: true, force: true })\n        try { await fs.unlink(`${itemPath}.meta`) } catch (e) { }\n        return { success: true, message: \"Permanently deleted\" }\n    } catch (error: any) {\n        return { success: false, message: error.message }\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA4TsB,oBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 2557, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/app/actions.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs/promises'\nimport path from 'path'\nimport os from 'os'\nimport { FileItem } from '@/lib/mockData'\n\nconst BASE_PATH = os.homedir()\n\nexport async function getFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(BASE_PATH, relativePath)\n\n        // Security check: Ensure we don't escape home directory (basic check)\n        if (!fullPath.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied: Cannot traverse above home directory\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n                else if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n\n                // Permission string simulation (Node fs doesn't give \"rwx\" string directly easily across platforms, \n                // but we can approximate from mode)\n                const perms = (stats.mode & parseInt('777', 8)).toString(8) // simple octal\n\n                return {\n                    id: entryPath, // Use path as ID\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}` // Mocking the rwx string is complex, showing octal for now\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error reading directory:\", error)\n        return []\n    }\n}\n\nimport { exec } from 'child_process'\nimport util from 'util'\n\nconst execAsync = util.promisify(exec)\n\nconst usernameCache = new Map<number, string>()\n\nasync function getUsername(uid: number): Promise<string> {\n    if (usernameCache.has(uid)) return usernameCache.get(uid)!\n    try {\n        const { stdout } = await execAsync(`id -nu ${uid}`)\n        const name = stdout.trim()\n        usernameCache.set(uid, name)\n        return name\n    } catch (e) {\n        return String(uid)\n    }\n}\n\nasync function userExists(username: string): Promise<boolean> {\n    try {\n        await execAsync(`id -u ${username}`)\n        return true\n    } catch (error) {\n        return false\n    }\n}\n\nexport async function shareFile(sourcePath: string, targetUsername: string): Promise<{ success: boolean, message: string }> {\n    // Validate target user exists\n    if (!await userExists(targetUsername)) {\n        return { success: false, message: `User '${targetUsername}' does not exist on this system.` }\n    }\n\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const targetUserDir = path.join(sharedRoot, targetUsername)\n\n        // Ensure shared directories exist\n        await fs.mkdir(targetUserDir, { recursive: true })\n\n        const sourceName = path.basename(sourcePath)\n        const destPath = path.join(targetUserDir, sourceName)\n\n        try {\n            await fs.symlink(sourcePath, destPath)\n            return { success: true, message: `Successfully shared with ${targetUsername}` }\n        } catch (e: any) {\n            if (e.code === 'EEXIST') {\n                return { success: false, message: `Already shared with ${targetUsername}` }\n            }\n            throw e\n        }\n    } catch (error: any) {\n        console.error(\"Error sharing file:\", error)\n        return { success: false, message: error.message || \"Failed to share file\" }\n    }\n}\n\nexport async function getFileShares(filePath: string): Promise<string[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n\n        // Scan all user directories in shared root\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n            const shares: string[] = []\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            if (target === filePath) {\n                                shares.push(userDir.name)\n                            }\n                        } catch (e) {\n                            // Not a symlink or other error, ignore\n                        }\n                    }\n                } catch (e) {\n                    // Cannot read user dir, ignore\n                }\n            }\n            return shares\n        } catch (e) {\n            // Shared root likely doesn't exist yet\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting shares:\", error)\n        return []\n    }\n}\n\nexport async function getSharedFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const currentUser = os.userInfo().username\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared', currentUser)\n\n        await fs.mkdir(sharedRoot, { recursive: true })\n\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(sharedRoot, relativePath)\n\n        // Security check\n        if (!fullPath.startsWith(sharedRoot)) {\n            throw new Error(\"Access denied: Cannot traverse above shared root\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n\n                // For shared files, we might want to know who shared it (the link owner usually)\n                // but lstat on the link itself in the parent dir might be needed if we want link info.\n                // For now, presenting the target file info is fine.\n\n                // Determine type extension logic same as getFiles\n                if (!entry.isDirectory()) {\n                    if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                    else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                    else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n                }\n\n                const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                return {\n                    id: entryPath,\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}`\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error getting shared files:\", error)\n        return []\n    }\n}\n\nexport interface SharedFileItem extends FileItem {\n    sharedWith: { username: string, linkPath: string }[]\n}\n\nexport async function getOutgoingShares(): Promise<SharedFileItem[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const myHome = os.homedir()\n\n        // Map of sourcePath -> { sharedWith: [] }\n        const shareMap = new Map<string, { username: string, linkPath: string }[]>()\n\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            // Check if target is inside my home directory (or belongs to me)\n                            // Ideally check if I own the target file\n                            if (target.startsWith(myHome)) {\n                                if (!shareMap.has(target)) {\n                                    shareMap.set(target, [])\n                                }\n                                shareMap.get(target)?.push({ username: userDir.name, linkPath })\n                            }\n                        } catch (e) {\n                            // Not a symlink\n                        }\n                    }\n                } catch (e) {\n                    // Ignore\n                }\n            }\n\n            // Convert map to SharedFileItem list\n            const results: SharedFileItem[] = []\n            for (const [filePath, shares] of shareMap.entries()) {\n                try {\n                    const stats = await fs.stat(filePath)\n                    const name = path.basename(filePath)\n\n                    let type: FileItem['type'] = 'file'\n                    if (stats.isDirectory()) type = 'folder'\n                    else if (name.endsWith('.sh') || name.endsWith('.py')) type = 'script'\n                    else if (name.endsWith('.csv') || name.endsWith('.json')) type = 'data'\n                    else if (name.endsWith('.zip') || name.endsWith('.tar') || name.endsWith('.gz')) type = 'archive'\n\n                    const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                    results.push({\n                        id: filePath,\n                        name: name,\n                        type: type,\n                        path: filePath,\n                        owner: await getUsername(stats.uid),\n                        group: String(stats.gid),\n                        modifiedAt: stats.mtime.toISOString(),\n                        sizeBytes: stats.size,\n                        permissions: `0${perms}`,\n                        sharedWith: shares\n                    })\n                } catch (e) {\n                    // File might have been deleted but link exists\n                }\n            }\n            return results\n\n        } catch (e) {\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting outgoing shares:\", error)\n        return []\n    }\n}\n\nexport async function unshareFile(targetUsername: string, fileName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const sharedLinkPath = path.join(os.homedir(), 'hpc_shared', targetUsername, fileName)\n        await fs.unlink(sharedLinkPath)\n        return { success: true, message: `Unshared ${fileName} with ${targetUsername}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to unshare\" }\n    }\n}\n\nexport async function changePermissions(filePath: string, mode: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.chmod(filePath, mode)\n        return { success: true, message: `Updated permissions for ${path.basename(filePath)}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to change permissions\" }\n    }\n}\n\nexport async function uploadFile(formData: FormData): Promise<{ success: boolean, message: string }> {\n    try {\n        const file = formData.get('file') as File\n        const currentPathSegments = JSON.parse(formData.get('pathSegments') as string)\n\n        if (!file) {\n            throw new Error(\"No file provided\")\n        }\n\n        const buffer = Buffer.from(await file.arrayBuffer())\n        const relativePath = path.join(...currentPathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.writeFile(path.join(targetDir, file.name), buffer)\n        return { success: true, message: `Uploaded ${file.name}` }\n    } catch (error: any) {\n        console.error(\"Upload error:\", error)\n        return { success: false, message: error.message || \"Upload failed\" }\n    }\n}\n\nexport async function createFolder(pathSegments: string[], folderName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const relativePath = path.join(...pathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath, folderName)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.mkdir(targetDir)\n        return { success: true, message: `Created folder ${folderName}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to create folder\" }\n    }\n}\n\nexport async function deleteItem(itemPath: string): Promise<{ success: boolean, message: string }> {\n    return moveToTrash(itemPath) // Default to trash\n}\n\nconst TRASH_PATH = path.join(os.homedir(), '.hpc_trash')\n\nexport async function moveToTrash(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n\n        const timestamp = Date.now()\n        const trashName = `${path.basename(itemPath)}_${timestamp}`\n        const trashPath = path.join(TRASH_PATH, trashName)\n\n        // Store metadata for restoration\n        const metadata = {\n            originalPath: itemPath,\n            deletedAt: new Date().toISOString()\n        }\n        await fs.writeFile(`${trashPath}.meta`, JSON.stringify(metadata))\n\n        await fs.rename(itemPath, trashPath)\n        return { success: true, message: `Moved to trash` }\n    } catch (error: any) {\n        console.error(\"Trash error:\", error)\n        return { success: false, message: error.message || \"Failed to move to trash\" }\n    }\n}\n\nexport async function getTrashFiles(): Promise<FileItem[]> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n        const entries = await fs.readdir(TRASH_PATH)\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            if (entry.endsWith('.meta')) return null\n\n            try {\n                const entryPath = path.join(TRASH_PATH, entry)\n                const stats = await fs.stat(entryPath)\n                const name = entry.split('_').slice(0, -1).join('_') || entry // Attempt to recover name\n\n                return {\n                    id: entryPath,\n                    name: name,\n                    type: stats.isDirectory() ? 'folder' : 'file',\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: '000' // Trash items usually treated differently\n                } as FileItem\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (e) {\n        return []\n    }\n}\n\nexport async function restoreFromTrash(trashPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        // Try to read metadata\n        const metaPath = `${trashPath}.meta`\n        let targetPath = path.join(os.homedir(), path.basename(trashPath).split('_').slice(0, -1).join('_'))\n\n        try {\n            const metaContent = await fs.readFile(metaPath, 'utf-8')\n            const metadata = JSON.parse(metaContent)\n            targetPath = metadata.originalPath\n        } catch (e) {\n            // Fallback used above\n        }\n\n        // Check if target exists\n        try {\n            await fs.access(targetPath)\n            return { success: false, message: \"Original location occupied. Rename or move file first.\" }\n        } catch (e) {\n            // Good, target doesn't exist\n        }\n\n        await fs.rename(trashPath, targetPath)\n        try { await fs.unlink(metaPath) } catch (e) { } // Delete meta if exists\n\n        return { success: true, message: \"Restored successfully\" }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to restore\" }\n    }\n}\n\nexport async function permanentDelete(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        if (!itemPath.startsWith(TRASH_PATH)) {\n            throw new Error(\"Access denied: Can only permanent delete from trash\")\n        }\n        await fs.rm(itemPath, { recursive: true, force: true })\n        try { await fs.unlink(`${itemPath}.meta`) } catch (e) { }\n        return { success: true, message: \"Permanently deleted\" }\n    } catch (error: any) {\n        return { success: false, message: error.message }\n    }\n}\n"],"names":[],"mappings":";;;;;;;IAqUsB,aAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 2569, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/app/actions.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs/promises'\nimport path from 'path'\nimport os from 'os'\nimport { FileItem } from '@/lib/mockData'\n\nconst BASE_PATH = os.homedir()\n\nexport async function getFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(BASE_PATH, relativePath)\n\n        // Security check: Ensure we don't escape home directory (basic check)\n        if (!fullPath.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied: Cannot traverse above home directory\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n                else if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n\n                // Permission string simulation (Node fs doesn't give \"rwx\" string directly easily across platforms, \n                // but we can approximate from mode)\n                const perms = (stats.mode & parseInt('777', 8)).toString(8) // simple octal\n\n                return {\n                    id: entryPath, // Use path as ID\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}` // Mocking the rwx string is complex, showing octal for now\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error reading directory:\", error)\n        return []\n    }\n}\n\nimport { exec } from 'child_process'\nimport util from 'util'\n\nconst execAsync = util.promisify(exec)\n\nconst usernameCache = new Map<number, string>()\n\nasync function getUsername(uid: number): Promise<string> {\n    if (usernameCache.has(uid)) return usernameCache.get(uid)!\n    try {\n        const { stdout } = await execAsync(`id -nu ${uid}`)\n        const name = stdout.trim()\n        usernameCache.set(uid, name)\n        return name\n    } catch (e) {\n        return String(uid)\n    }\n}\n\nasync function userExists(username: string): Promise<boolean> {\n    try {\n        await execAsync(`id -u ${username}`)\n        return true\n    } catch (error) {\n        return false\n    }\n}\n\nexport async function shareFile(sourcePath: string, targetUsername: string): Promise<{ success: boolean, message: string }> {\n    // Validate target user exists\n    if (!await userExists(targetUsername)) {\n        return { success: false, message: `User '${targetUsername}' does not exist on this system.` }\n    }\n\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const targetUserDir = path.join(sharedRoot, targetUsername)\n\n        // Ensure shared directories exist\n        await fs.mkdir(targetUserDir, { recursive: true })\n\n        const sourceName = path.basename(sourcePath)\n        const destPath = path.join(targetUserDir, sourceName)\n\n        try {\n            await fs.symlink(sourcePath, destPath)\n            return { success: true, message: `Successfully shared with ${targetUsername}` }\n        } catch (e: any) {\n            if (e.code === 'EEXIST') {\n                return { success: false, message: `Already shared with ${targetUsername}` }\n            }\n            throw e\n        }\n    } catch (error: any) {\n        console.error(\"Error sharing file:\", error)\n        return { success: false, message: error.message || \"Failed to share file\" }\n    }\n}\n\nexport async function getFileShares(filePath: string): Promise<string[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n\n        // Scan all user directories in shared root\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n            const shares: string[] = []\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            if (target === filePath) {\n                                shares.push(userDir.name)\n                            }\n                        } catch (e) {\n                            // Not a symlink or other error, ignore\n                        }\n                    }\n                } catch (e) {\n                    // Cannot read user dir, ignore\n                }\n            }\n            return shares\n        } catch (e) {\n            // Shared root likely doesn't exist yet\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting shares:\", error)\n        return []\n    }\n}\n\nexport async function getSharedFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const currentUser = os.userInfo().username\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared', currentUser)\n\n        await fs.mkdir(sharedRoot, { recursive: true })\n\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(sharedRoot, relativePath)\n\n        // Security check\n        if (!fullPath.startsWith(sharedRoot)) {\n            throw new Error(\"Access denied: Cannot traverse above shared root\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n\n                // For shared files, we might want to know who shared it (the link owner usually)\n                // but lstat on the link itself in the parent dir might be needed if we want link info.\n                // For now, presenting the target file info is fine.\n\n                // Determine type extension logic same as getFiles\n                if (!entry.isDirectory()) {\n                    if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                    else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                    else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n                }\n\n                const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                return {\n                    id: entryPath,\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}`\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error getting shared files:\", error)\n        return []\n    }\n}\n\nexport interface SharedFileItem extends FileItem {\n    sharedWith: { username: string, linkPath: string }[]\n}\n\nexport async function getOutgoingShares(): Promise<SharedFileItem[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const myHome = os.homedir()\n\n        // Map of sourcePath -> { sharedWith: [] }\n        const shareMap = new Map<string, { username: string, linkPath: string }[]>()\n\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            // Check if target is inside my home directory (or belongs to me)\n                            // Ideally check if I own the target file\n                            if (target.startsWith(myHome)) {\n                                if (!shareMap.has(target)) {\n                                    shareMap.set(target, [])\n                                }\n                                shareMap.get(target)?.push({ username: userDir.name, linkPath })\n                            }\n                        } catch (e) {\n                            // Not a symlink\n                        }\n                    }\n                } catch (e) {\n                    // Ignore\n                }\n            }\n\n            // Convert map to SharedFileItem list\n            const results: SharedFileItem[] = []\n            for (const [filePath, shares] of shareMap.entries()) {\n                try {\n                    const stats = await fs.stat(filePath)\n                    const name = path.basename(filePath)\n\n                    let type: FileItem['type'] = 'file'\n                    if (stats.isDirectory()) type = 'folder'\n                    else if (name.endsWith('.sh') || name.endsWith('.py')) type = 'script'\n                    else if (name.endsWith('.csv') || name.endsWith('.json')) type = 'data'\n                    else if (name.endsWith('.zip') || name.endsWith('.tar') || name.endsWith('.gz')) type = 'archive'\n\n                    const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                    results.push({\n                        id: filePath,\n                        name: name,\n                        type: type,\n                        path: filePath,\n                        owner: await getUsername(stats.uid),\n                        group: String(stats.gid),\n                        modifiedAt: stats.mtime.toISOString(),\n                        sizeBytes: stats.size,\n                        permissions: `0${perms}`,\n                        sharedWith: shares\n                    })\n                } catch (e) {\n                    // File might have been deleted but link exists\n                }\n            }\n            return results\n\n        } catch (e) {\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting outgoing shares:\", error)\n        return []\n    }\n}\n\nexport async function unshareFile(targetUsername: string, fileName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const sharedLinkPath = path.join(os.homedir(), 'hpc_shared', targetUsername, fileName)\n        await fs.unlink(sharedLinkPath)\n        return { success: true, message: `Unshared ${fileName} with ${targetUsername}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to unshare\" }\n    }\n}\n\nexport async function changePermissions(filePath: string, mode: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.chmod(filePath, mode)\n        return { success: true, message: `Updated permissions for ${path.basename(filePath)}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to change permissions\" }\n    }\n}\n\nexport async function uploadFile(formData: FormData): Promise<{ success: boolean, message: string }> {\n    try {\n        const file = formData.get('file') as File\n        const currentPathSegments = JSON.parse(formData.get('pathSegments') as string)\n\n        if (!file) {\n            throw new Error(\"No file provided\")\n        }\n\n        const buffer = Buffer.from(await file.arrayBuffer())\n        const relativePath = path.join(...currentPathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.writeFile(path.join(targetDir, file.name), buffer)\n        return { success: true, message: `Uploaded ${file.name}` }\n    } catch (error: any) {\n        console.error(\"Upload error:\", error)\n        return { success: false, message: error.message || \"Upload failed\" }\n    }\n}\n\nexport async function createFolder(pathSegments: string[], folderName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const relativePath = path.join(...pathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath, folderName)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.mkdir(targetDir)\n        return { success: true, message: `Created folder ${folderName}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to create folder\" }\n    }\n}\n\nexport async function deleteItem(itemPath: string): Promise<{ success: boolean, message: string }> {\n    return moveToTrash(itemPath) // Default to trash\n}\n\nconst TRASH_PATH = path.join(os.homedir(), '.hpc_trash')\n\nexport async function moveToTrash(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n\n        const timestamp = Date.now()\n        const trashName = `${path.basename(itemPath)}_${timestamp}`\n        const trashPath = path.join(TRASH_PATH, trashName)\n\n        // Store metadata for restoration\n        const metadata = {\n            originalPath: itemPath,\n            deletedAt: new Date().toISOString()\n        }\n        await fs.writeFile(`${trashPath}.meta`, JSON.stringify(metadata))\n\n        await fs.rename(itemPath, trashPath)\n        return { success: true, message: `Moved to trash` }\n    } catch (error: any) {\n        console.error(\"Trash error:\", error)\n        return { success: false, message: error.message || \"Failed to move to trash\" }\n    }\n}\n\nexport async function getTrashFiles(): Promise<FileItem[]> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n        const entries = await fs.readdir(TRASH_PATH)\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            if (entry.endsWith('.meta')) return null\n\n            try {\n                const entryPath = path.join(TRASH_PATH, entry)\n                const stats = await fs.stat(entryPath)\n                const name = entry.split('_').slice(0, -1).join('_') || entry // Attempt to recover name\n\n                return {\n                    id: entryPath,\n                    name: name,\n                    type: stats.isDirectory() ? 'folder' : 'file',\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: '000' // Trash items usually treated differently\n                } as FileItem\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (e) {\n        return []\n    }\n}\n\nexport async function restoreFromTrash(trashPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        // Try to read metadata\n        const metaPath = `${trashPath}.meta`\n        let targetPath = path.join(os.homedir(), path.basename(trashPath).split('_').slice(0, -1).join('_'))\n\n        try {\n            const metaContent = await fs.readFile(metaPath, 'utf-8')\n            const metadata = JSON.parse(metaContent)\n            targetPath = metadata.originalPath\n        } catch (e) {\n            // Fallback used above\n        }\n\n        // Check if target exists\n        try {\n            await fs.access(targetPath)\n            return { success: false, message: \"Original location occupied. Rename or move file first.\" }\n        } catch (e) {\n            // Good, target doesn't exist\n        }\n\n        await fs.rename(trashPath, targetPath)\n        try { await fs.unlink(metaPath) } catch (e) { } // Delete meta if exists\n\n        return { success: true, message: \"Restored successfully\" }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to restore\" }\n    }\n}\n\nexport async function permanentDelete(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        if (!itemPath.startsWith(TRASH_PATH)) {\n            throw new Error(\"Access denied: Can only permanent delete from trash\")\n        }\n        await fs.rm(itemPath, { recursive: true, force: true })\n        try { await fs.unlink(`${itemPath}.meta`) } catch (e) { }\n        return { success: true, message: \"Permanently deleted\" }\n    } catch (error: any) {\n        return { success: false, message: error.message }\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA8VsB,eAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 2581, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/app/actions.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs/promises'\nimport path from 'path'\nimport os from 'os'\nimport { FileItem } from '@/lib/mockData'\n\nconst BASE_PATH = os.homedir()\n\nexport async function getFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(BASE_PATH, relativePath)\n\n        // Security check: Ensure we don't escape home directory (basic check)\n        if (!fullPath.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied: Cannot traverse above home directory\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n                else if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n\n                // Permission string simulation (Node fs doesn't give \"rwx\" string directly easily across platforms, \n                // but we can approximate from mode)\n                const perms = (stats.mode & parseInt('777', 8)).toString(8) // simple octal\n\n                return {\n                    id: entryPath, // Use path as ID\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}` // Mocking the rwx string is complex, showing octal for now\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error reading directory:\", error)\n        return []\n    }\n}\n\nimport { exec } from 'child_process'\nimport util from 'util'\n\nconst execAsync = util.promisify(exec)\n\nconst usernameCache = new Map<number, string>()\n\nasync function getUsername(uid: number): Promise<string> {\n    if (usernameCache.has(uid)) return usernameCache.get(uid)!\n    try {\n        const { stdout } = await execAsync(`id -nu ${uid}`)\n        const name = stdout.trim()\n        usernameCache.set(uid, name)\n        return name\n    } catch (e) {\n        return String(uid)\n    }\n}\n\nasync function userExists(username: string): Promise<boolean> {\n    try {\n        await execAsync(`id -u ${username}`)\n        return true\n    } catch (error) {\n        return false\n    }\n}\n\nexport async function shareFile(sourcePath: string, targetUsername: string): Promise<{ success: boolean, message: string }> {\n    // Validate target user exists\n    if (!await userExists(targetUsername)) {\n        return { success: false, message: `User '${targetUsername}' does not exist on this system.` }\n    }\n\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const targetUserDir = path.join(sharedRoot, targetUsername)\n\n        // Ensure shared directories exist\n        await fs.mkdir(targetUserDir, { recursive: true })\n\n        const sourceName = path.basename(sourcePath)\n        const destPath = path.join(targetUserDir, sourceName)\n\n        try {\n            await fs.symlink(sourcePath, destPath)\n            return { success: true, message: `Successfully shared with ${targetUsername}` }\n        } catch (e: any) {\n            if (e.code === 'EEXIST') {\n                return { success: false, message: `Already shared with ${targetUsername}` }\n            }\n            throw e\n        }\n    } catch (error: any) {\n        console.error(\"Error sharing file:\", error)\n        return { success: false, message: error.message || \"Failed to share file\" }\n    }\n}\n\nexport async function getFileShares(filePath: string): Promise<string[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n\n        // Scan all user directories in shared root\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n            const shares: string[] = []\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            if (target === filePath) {\n                                shares.push(userDir.name)\n                            }\n                        } catch (e) {\n                            // Not a symlink or other error, ignore\n                        }\n                    }\n                } catch (e) {\n                    // Cannot read user dir, ignore\n                }\n            }\n            return shares\n        } catch (e) {\n            // Shared root likely doesn't exist yet\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting shares:\", error)\n        return []\n    }\n}\n\nexport async function getSharedFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const currentUser = os.userInfo().username\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared', currentUser)\n\n        await fs.mkdir(sharedRoot, { recursive: true })\n\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(sharedRoot, relativePath)\n\n        // Security check\n        if (!fullPath.startsWith(sharedRoot)) {\n            throw new Error(\"Access denied: Cannot traverse above shared root\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n\n                // For shared files, we might want to know who shared it (the link owner usually)\n                // but lstat on the link itself in the parent dir might be needed if we want link info.\n                // For now, presenting the target file info is fine.\n\n                // Determine type extension logic same as getFiles\n                if (!entry.isDirectory()) {\n                    if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                    else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                    else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n                }\n\n                const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                return {\n                    id: entryPath,\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}`\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error getting shared files:\", error)\n        return []\n    }\n}\n\nexport interface SharedFileItem extends FileItem {\n    sharedWith: { username: string, linkPath: string }[]\n}\n\nexport async function getOutgoingShares(): Promise<SharedFileItem[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const myHome = os.homedir()\n\n        // Map of sourcePath -> { sharedWith: [] }\n        const shareMap = new Map<string, { username: string, linkPath: string }[]>()\n\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            // Check if target is inside my home directory (or belongs to me)\n                            // Ideally check if I own the target file\n                            if (target.startsWith(myHome)) {\n                                if (!shareMap.has(target)) {\n                                    shareMap.set(target, [])\n                                }\n                                shareMap.get(target)?.push({ username: userDir.name, linkPath })\n                            }\n                        } catch (e) {\n                            // Not a symlink\n                        }\n                    }\n                } catch (e) {\n                    // Ignore\n                }\n            }\n\n            // Convert map to SharedFileItem list\n            const results: SharedFileItem[] = []\n            for (const [filePath, shares] of shareMap.entries()) {\n                try {\n                    const stats = await fs.stat(filePath)\n                    const name = path.basename(filePath)\n\n                    let type: FileItem['type'] = 'file'\n                    if (stats.isDirectory()) type = 'folder'\n                    else if (name.endsWith('.sh') || name.endsWith('.py')) type = 'script'\n                    else if (name.endsWith('.csv') || name.endsWith('.json')) type = 'data'\n                    else if (name.endsWith('.zip') || name.endsWith('.tar') || name.endsWith('.gz')) type = 'archive'\n\n                    const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                    results.push({\n                        id: filePath,\n                        name: name,\n                        type: type,\n                        path: filePath,\n                        owner: await getUsername(stats.uid),\n                        group: String(stats.gid),\n                        modifiedAt: stats.mtime.toISOString(),\n                        sizeBytes: stats.size,\n                        permissions: `0${perms}`,\n                        sharedWith: shares\n                    })\n                } catch (e) {\n                    // File might have been deleted but link exists\n                }\n            }\n            return results\n\n        } catch (e) {\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting outgoing shares:\", error)\n        return []\n    }\n}\n\nexport async function unshareFile(targetUsername: string, fileName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const sharedLinkPath = path.join(os.homedir(), 'hpc_shared', targetUsername, fileName)\n        await fs.unlink(sharedLinkPath)\n        return { success: true, message: `Unshared ${fileName} with ${targetUsername}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to unshare\" }\n    }\n}\n\nexport async function changePermissions(filePath: string, mode: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.chmod(filePath, mode)\n        return { success: true, message: `Updated permissions for ${path.basename(filePath)}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to change permissions\" }\n    }\n}\n\nexport async function uploadFile(formData: FormData): Promise<{ success: boolean, message: string }> {\n    try {\n        const file = formData.get('file') as File\n        const currentPathSegments = JSON.parse(formData.get('pathSegments') as string)\n\n        if (!file) {\n            throw new Error(\"No file provided\")\n        }\n\n        const buffer = Buffer.from(await file.arrayBuffer())\n        const relativePath = path.join(...currentPathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.writeFile(path.join(targetDir, file.name), buffer)\n        return { success: true, message: `Uploaded ${file.name}` }\n    } catch (error: any) {\n        console.error(\"Upload error:\", error)\n        return { success: false, message: error.message || \"Upload failed\" }\n    }\n}\n\nexport async function createFolder(pathSegments: string[], folderName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const relativePath = path.join(...pathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath, folderName)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.mkdir(targetDir)\n        return { success: true, message: `Created folder ${folderName}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to create folder\" }\n    }\n}\n\nexport async function deleteItem(itemPath: string): Promise<{ success: boolean, message: string }> {\n    return moveToTrash(itemPath) // Default to trash\n}\n\nconst TRASH_PATH = path.join(os.homedir(), '.hpc_trash')\n\nexport async function moveToTrash(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n\n        const timestamp = Date.now()\n        const trashName = `${path.basename(itemPath)}_${timestamp}`\n        const trashPath = path.join(TRASH_PATH, trashName)\n\n        // Store metadata for restoration\n        const metadata = {\n            originalPath: itemPath,\n            deletedAt: new Date().toISOString()\n        }\n        await fs.writeFile(`${trashPath}.meta`, JSON.stringify(metadata))\n\n        await fs.rename(itemPath, trashPath)\n        return { success: true, message: `Moved to trash` }\n    } catch (error: any) {\n        console.error(\"Trash error:\", error)\n        return { success: false, message: error.message || \"Failed to move to trash\" }\n    }\n}\n\nexport async function getTrashFiles(): Promise<FileItem[]> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n        const entries = await fs.readdir(TRASH_PATH)\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            if (entry.endsWith('.meta')) return null\n\n            try {\n                const entryPath = path.join(TRASH_PATH, entry)\n                const stats = await fs.stat(entryPath)\n                const name = entry.split('_').slice(0, -1).join('_') || entry // Attempt to recover name\n\n                return {\n                    id: entryPath,\n                    name: name,\n                    type: stats.isDirectory() ? 'folder' : 'file',\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: '000' // Trash items usually treated differently\n                } as FileItem\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (e) {\n        return []\n    }\n}\n\nexport async function restoreFromTrash(trashPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        // Try to read metadata\n        const metaPath = `${trashPath}.meta`\n        let targetPath = path.join(os.homedir(), path.basename(trashPath).split('_').slice(0, -1).join('_'))\n\n        try {\n            const metaContent = await fs.readFile(metaPath, 'utf-8')\n            const metadata = JSON.parse(metaContent)\n            targetPath = metadata.originalPath\n        } catch (e) {\n            // Fallback used above\n        }\n\n        // Check if target exists\n        try {\n            await fs.access(targetPath)\n            return { success: false, message: \"Original location occupied. Rename or move file first.\" }\n        } catch (e) {\n            // Good, target doesn't exist\n        }\n\n        await fs.rename(trashPath, targetPath)\n        try { await fs.unlink(metaPath) } catch (e) { } // Delete meta if exists\n\n        return { success: true, message: \"Restored successfully\" }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to restore\" }\n    }\n}\n\nexport async function permanentDelete(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        if (!itemPath.startsWith(TRASH_PATH)) {\n            throw new Error(\"Access denied: Can only permanent delete from trash\")\n        }\n        await fs.rm(itemPath, { recursive: true, force: true })\n        try { await fs.unlink(`${itemPath}.meta`) } catch (e) { }\n        return { success: true, message: \"Permanently deleted\" }\n    } catch (error: any) {\n        return { success: false, message: error.message }\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA8WsB,aAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 2593, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/app/actions.ts"],"sourcesContent":["'use server'\n\nimport fs from 'fs/promises'\nimport path from 'path'\nimport os from 'os'\nimport { FileItem } from '@/lib/mockData'\n\nconst BASE_PATH = os.homedir()\n\nexport async function getFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(BASE_PATH, relativePath)\n\n        // Security check: Ensure we don't escape home directory (basic check)\n        if (!fullPath.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied: Cannot traverse above home directory\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n                else if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n\n                // Permission string simulation (Node fs doesn't give \"rwx\" string directly easily across platforms, \n                // but we can approximate from mode)\n                const perms = (stats.mode & parseInt('777', 8)).toString(8) // simple octal\n\n                return {\n                    id: entryPath, // Use path as ID\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}` // Mocking the rwx string is complex, showing octal for now\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error reading directory:\", error)\n        return []\n    }\n}\n\nimport { exec } from 'child_process'\nimport util from 'util'\n\nconst execAsync = util.promisify(exec)\n\nconst usernameCache = new Map<number, string>()\n\nasync function getUsername(uid: number): Promise<string> {\n    if (usernameCache.has(uid)) return usernameCache.get(uid)!\n    try {\n        const { stdout } = await execAsync(`id -nu ${uid}`)\n        const name = stdout.trim()\n        usernameCache.set(uid, name)\n        return name\n    } catch (e) {\n        return String(uid)\n    }\n}\n\nasync function userExists(username: string): Promise<boolean> {\n    try {\n        await execAsync(`id -u ${username}`)\n        return true\n    } catch (error) {\n        return false\n    }\n}\n\nexport async function shareFile(sourcePath: string, targetUsername: string): Promise<{ success: boolean, message: string }> {\n    // Validate target user exists\n    if (!await userExists(targetUsername)) {\n        return { success: false, message: `User '${targetUsername}' does not exist on this system.` }\n    }\n\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const targetUserDir = path.join(sharedRoot, targetUsername)\n\n        // Ensure shared directories exist\n        await fs.mkdir(targetUserDir, { recursive: true })\n\n        const sourceName = path.basename(sourcePath)\n        const destPath = path.join(targetUserDir, sourceName)\n\n        try {\n            await fs.symlink(sourcePath, destPath)\n            return { success: true, message: `Successfully shared with ${targetUsername}` }\n        } catch (e: any) {\n            if (e.code === 'EEXIST') {\n                return { success: false, message: `Already shared with ${targetUsername}` }\n            }\n            throw e\n        }\n    } catch (error: any) {\n        console.error(\"Error sharing file:\", error)\n        return { success: false, message: error.message || \"Failed to share file\" }\n    }\n}\n\nexport async function getFileShares(filePath: string): Promise<string[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n\n        // Scan all user directories in shared root\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n            const shares: string[] = []\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            if (target === filePath) {\n                                shares.push(userDir.name)\n                            }\n                        } catch (e) {\n                            // Not a symlink or other error, ignore\n                        }\n                    }\n                } catch (e) {\n                    // Cannot read user dir, ignore\n                }\n            }\n            return shares\n        } catch (e) {\n            // Shared root likely doesn't exist yet\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting shares:\", error)\n        return []\n    }\n}\n\nexport async function getSharedFiles(currentPathSegments: string[]): Promise<FileItem[]> {\n    try {\n        const currentUser = os.userInfo().username\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared', currentUser)\n\n        await fs.mkdir(sharedRoot, { recursive: true })\n\n        const relativePath = path.join(...currentPathSegments)\n        const fullPath = path.join(sharedRoot, relativePath)\n\n        // Security check\n        if (!fullPath.startsWith(sharedRoot)) {\n            throw new Error(\"Access denied: Cannot traverse above shared root\")\n        }\n\n        const entries = await fs.readdir(fullPath, { withFileTypes: true })\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            try {\n                const entryPath = path.join(fullPath, entry.name)\n                const stats = await fs.stat(entryPath)\n\n                let type: FileItem['type'] = 'file'\n                if (entry.isDirectory()) type = 'folder'\n\n                // For shared files, we might want to know who shared it (the link owner usually)\n                // but lstat on the link itself in the parent dir might be needed if we want link info.\n                // For now, presenting the target file info is fine.\n\n                // Determine type extension logic same as getFiles\n                if (!entry.isDirectory()) {\n                    if (entry.name.endsWith('.sh') || entry.name.endsWith('.py')) type = 'script'\n                    else if (entry.name.endsWith('.csv') || entry.name.endsWith('.json')) type = 'data'\n                    else if (entry.name.endsWith('.zip') || entry.name.endsWith('.tar') || entry.name.endsWith('.gz')) type = 'archive'\n                }\n\n                const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                return {\n                    id: entryPath,\n                    name: entry.name,\n                    type: type,\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: `0${perms}`\n                }\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (error) {\n        console.error(\"Error getting shared files:\", error)\n        return []\n    }\n}\n\nexport interface SharedFileItem extends FileItem {\n    sharedWith: { username: string, linkPath: string }[]\n}\n\nexport async function getOutgoingShares(): Promise<SharedFileItem[]> {\n    try {\n        const sharedRoot = path.join(os.homedir(), 'hpc_shared')\n        const myHome = os.homedir()\n\n        // Map of sourcePath -> { sharedWith: [] }\n        const shareMap = new Map<string, { username: string, linkPath: string }[]>()\n\n        try {\n            const userDirs = await fs.readdir(sharedRoot, { withFileTypes: true })\n\n            for (const userDir of userDirs) {\n                if (!userDir.isDirectory()) continue\n\n                const userPath = path.join(sharedRoot, userDir.name)\n                try {\n                    const links = await fs.readdir(userPath)\n\n                    for (const link of links) {\n                        const linkPath = path.join(userPath, link)\n                        try {\n                            const target = await fs.readlink(linkPath)\n                            // Check if target is inside my home directory (or belongs to me)\n                            // Ideally check if I own the target file\n                            if (target.startsWith(myHome)) {\n                                if (!shareMap.has(target)) {\n                                    shareMap.set(target, [])\n                                }\n                                shareMap.get(target)?.push({ username: userDir.name, linkPath })\n                            }\n                        } catch (e) {\n                            // Not a symlink\n                        }\n                    }\n                } catch (e) {\n                    // Ignore\n                }\n            }\n\n            // Convert map to SharedFileItem list\n            const results: SharedFileItem[] = []\n            for (const [filePath, shares] of shareMap.entries()) {\n                try {\n                    const stats = await fs.stat(filePath)\n                    const name = path.basename(filePath)\n\n                    let type: FileItem['type'] = 'file'\n                    if (stats.isDirectory()) type = 'folder'\n                    else if (name.endsWith('.sh') || name.endsWith('.py')) type = 'script'\n                    else if (name.endsWith('.csv') || name.endsWith('.json')) type = 'data'\n                    else if (name.endsWith('.zip') || name.endsWith('.tar') || name.endsWith('.gz')) type = 'archive'\n\n                    const perms = (stats.mode & parseInt('777', 8)).toString(8)\n\n                    results.push({\n                        id: filePath,\n                        name: name,\n                        type: type,\n                        path: filePath,\n                        owner: await getUsername(stats.uid),\n                        group: String(stats.gid),\n                        modifiedAt: stats.mtime.toISOString(),\n                        sizeBytes: stats.size,\n                        permissions: `0${perms}`,\n                        sharedWith: shares\n                    })\n                } catch (e) {\n                    // File might have been deleted but link exists\n                }\n            }\n            return results\n\n        } catch (e) {\n            return []\n        }\n    } catch (error) {\n        console.error(\"Error getting outgoing shares:\", error)\n        return []\n    }\n}\n\nexport async function unshareFile(targetUsername: string, fileName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const sharedLinkPath = path.join(os.homedir(), 'hpc_shared', targetUsername, fileName)\n        await fs.unlink(sharedLinkPath)\n        return { success: true, message: `Unshared ${fileName} with ${targetUsername}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to unshare\" }\n    }\n}\n\nexport async function changePermissions(filePath: string, mode: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.chmod(filePath, mode)\n        return { success: true, message: `Updated permissions for ${path.basename(filePath)}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to change permissions\" }\n    }\n}\n\nexport async function uploadFile(formData: FormData): Promise<{ success: boolean, message: string }> {\n    try {\n        const file = formData.get('file') as File\n        const currentPathSegments = JSON.parse(formData.get('pathSegments') as string)\n\n        if (!file) {\n            throw new Error(\"No file provided\")\n        }\n\n        const buffer = Buffer.from(await file.arrayBuffer())\n        const relativePath = path.join(...currentPathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.writeFile(path.join(targetDir, file.name), buffer)\n        return { success: true, message: `Uploaded ${file.name}` }\n    } catch (error: any) {\n        console.error(\"Upload error:\", error)\n        return { success: false, message: error.message || \"Upload failed\" }\n    }\n}\n\nexport async function createFolder(pathSegments: string[], folderName: string): Promise<{ success: boolean, message: string }> {\n    try {\n        const relativePath = path.join(...pathSegments)\n        const targetDir = path.join(BASE_PATH, relativePath, folderName)\n\n        if (!targetDir.startsWith(BASE_PATH)) {\n            throw new Error(\"Access denied\")\n        }\n\n        await fs.mkdir(targetDir)\n        return { success: true, message: `Created folder ${folderName}` }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to create folder\" }\n    }\n}\n\nexport async function deleteItem(itemPath: string): Promise<{ success: boolean, message: string }> {\n    return moveToTrash(itemPath) // Default to trash\n}\n\nconst TRASH_PATH = path.join(os.homedir(), '.hpc_trash')\n\nexport async function moveToTrash(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n\n        const timestamp = Date.now()\n        const trashName = `${path.basename(itemPath)}_${timestamp}`\n        const trashPath = path.join(TRASH_PATH, trashName)\n\n        // Store metadata for restoration\n        const metadata = {\n            originalPath: itemPath,\n            deletedAt: new Date().toISOString()\n        }\n        await fs.writeFile(`${trashPath}.meta`, JSON.stringify(metadata))\n\n        await fs.rename(itemPath, trashPath)\n        return { success: true, message: `Moved to trash` }\n    } catch (error: any) {\n        console.error(\"Trash error:\", error)\n        return { success: false, message: error.message || \"Failed to move to trash\" }\n    }\n}\n\nexport async function getTrashFiles(): Promise<FileItem[]> {\n    try {\n        await fs.mkdir(TRASH_PATH, { recursive: true })\n        const entries = await fs.readdir(TRASH_PATH)\n\n        const files = await Promise.all(entries.map(async (entry) => {\n            if (entry.endsWith('.meta')) return null\n\n            try {\n                const entryPath = path.join(TRASH_PATH, entry)\n                const stats = await fs.stat(entryPath)\n                const name = entry.split('_').slice(0, -1).join('_') || entry // Attempt to recover name\n\n                return {\n                    id: entryPath,\n                    name: name,\n                    type: stats.isDirectory() ? 'folder' : 'file',\n                    path: entryPath,\n                    owner: await getUsername(stats.uid),\n                    group: String(stats.gid),\n                    modifiedAt: stats.mtime.toISOString(),\n                    sizeBytes: stats.size,\n                    permissions: '000' // Trash items usually treated differently\n                } as FileItem\n            } catch (e) {\n                return null\n            }\n        }))\n\n        return files.filter((f): f is FileItem => f !== null)\n    } catch (e) {\n        return []\n    }\n}\n\nexport async function restoreFromTrash(trashPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        // Try to read metadata\n        const metaPath = `${trashPath}.meta`\n        let targetPath = path.join(os.homedir(), path.basename(trashPath).split('_').slice(0, -1).join('_'))\n\n        try {\n            const metaContent = await fs.readFile(metaPath, 'utf-8')\n            const metadata = JSON.parse(metaContent)\n            targetPath = metadata.originalPath\n        } catch (e) {\n            // Fallback used above\n        }\n\n        // Check if target exists\n        try {\n            await fs.access(targetPath)\n            return { success: false, message: \"Original location occupied. Rename or move file first.\" }\n        } catch (e) {\n            // Good, target doesn't exist\n        }\n\n        await fs.rename(trashPath, targetPath)\n        try { await fs.unlink(metaPath) } catch (e) { } // Delete meta if exists\n\n        return { success: true, message: \"Restored successfully\" }\n    } catch (error: any) {\n        return { success: false, message: error.message || \"Failed to restore\" }\n    }\n}\n\nexport async function permanentDelete(itemPath: string): Promise<{ success: boolean, message: string }> {\n    try {\n        if (!itemPath.startsWith(TRASH_PATH)) {\n            throw new Error(\"Access denied: Can only permanent delete from trash\")\n        }\n        await fs.rm(itemPath, { recursive: true, force: true })\n        try { await fs.unlink(`${itemPath}.meta`) } catch (e) { }\n        return { success: true, message: \"Permanently deleted\" }\n    } catch (error: any) {\n        return { success: false, message: error.message }\n    }\n}\n"],"names":[],"mappings":";;;;;;;IA2YsB,gBAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 2605, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/components/ui/tabs.tsx"],"sourcesContent":["'use client'\n\nimport * as React from 'react'\nimport * as TabsPrimitive from '@radix-ui/react-tabs'\n\nimport { cn } from '@/lib/utils'\n\nfunction Tabs({\n  className,\n  ...props\n}: React.ComponentProps<typeof TabsPrimitive.Root>) {\n  return (\n    <TabsPrimitive.Root\n      data-slot=\"tabs\"\n      className={cn('flex flex-col gap-2', className)}\n      {...props}\n    />\n  )\n}\n\nfunction TabsList({\n  className,\n  ...props\n}: React.ComponentProps<typeof TabsPrimitive.List>) {\n  return (\n    <TabsPrimitive.List\n      data-slot=\"tabs-list\"\n      className={cn(\n        'bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction TabsTrigger({\n  className,\n  ...props\n}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {\n  return (\n    <TabsPrimitive.Trigger\n      data-slot=\"tabs-trigger\"\n      className={cn(\n        \"data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\",\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction TabsContent({\n  className,\n  ...props\n}: React.ComponentProps<typeof TabsPrimitive.Content>) {\n  return (\n    <TabsPrimitive.Content\n      data-slot=\"tabs-content\"\n      className={cn('flex-1 outline-none', className)}\n      {...props}\n    />\n  )\n}\n\nexport { Tabs, TabsList, TabsTrigger, TabsContent }\n"],"names":[],"mappings":";;;;;;;;;;;AAGA;AAEA;AALA;;;;AAOA,SAAS,KAAK,EACZ,SAAS,EACT,GAAG,OAC6C;IAChD,qBACE,8OAAC,wKAAkB;QACjB,aAAU;QACV,WAAW,IAAA,kHAAE,EAAC,uBAAuB;QACpC,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,SAAS,EAChB,SAAS,EACT,GAAG,OAC6C;IAChD,qBACE,8OAAC,wKAAkB;QACjB,aAAU;QACV,WAAW,IAAA,kHAAE,EACX,uGACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,YAAY,EACnB,SAAS,EACT,GAAG,OACgD;IACnD,qBACE,8OAAC,2KAAqB;QACpB,aAAU;QACV,WAAW,IAAA,kHAAE,EACX,mqBACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,YAAY,EACnB,SAAS,EACT,GAAG,OACgD;IACnD,qBACE,8OAAC,2KAAqB;QACpB,aAAU;QACV,WAAW,IAAA,kHAAE,EAAC,uBAAuB;QACpC,GAAG,KAAK;;;;;;AAGf"}},
    {"offset": {"line": 2671, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/components/ui/badge.tsx"],"sourcesContent":["import * as React from 'react'\nimport { Slot } from '@radix-ui/react-slot'\nimport { cva, type VariantProps } from 'class-variance-authority'\n\nimport { cn } from '@/lib/utils'\n\nconst badgeVariants = cva(\n  'inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden',\n  {\n    variants: {\n      variant: {\n        default:\n          'border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90',\n        secondary:\n          'border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90',\n        destructive:\n          'border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60',\n        outline:\n          'text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground',\n      },\n    },\n    defaultVariants: {\n      variant: 'default',\n    },\n  },\n)\n\nfunction Badge({\n  className,\n  variant,\n  asChild = false,\n  ...props\n}: React.ComponentProps<'span'> &\n  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {\n  const Comp = asChild ? Slot : 'span'\n\n  return (\n    <Comp\n      data-slot=\"badge\"\n      className={cn(badgeVariants({ variant }), className)}\n      {...props}\n    />\n  )\n}\n\nexport { Badge, badgeVariants }\n"],"names":[],"mappings":";;;;;;;AACA;AACA;AAEA;;;;;AAEA,MAAM,gBAAgB,IAAA,uKAAG,EACvB,kZACA;IACE,UAAU;QACR,SAAS;YACP,SACE;YACF,WACE;YACF,aACE;YACF,SACE;QACJ;IACF;IACA,iBAAiB;QACf,SAAS;IACX;AACF;AAGF,SAAS,MAAM,EACb,SAAS,EACT,OAAO,EACP,UAAU,KAAK,EACf,GAAG,OAEuD;IAC1D,MAAM,OAAO,UAAU,wKAAI,GAAG;IAE9B,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kHAAE,EAAC,cAAc;YAAE;QAAQ,IAAI;QACzC,GAAG,KAAK;;;;;;AAGf"}},
    {"offset": {"line": 2717, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/components/ui/breadcrumb.tsx"],"sourcesContent":["import * as React from 'react'\nimport { Slot } from '@radix-ui/react-slot'\nimport { ChevronRight, MoreHorizontal } from 'lucide-react'\n\nimport { cn } from '@/lib/utils'\n\nfunction Breadcrumb({ ...props }: React.ComponentProps<'nav'>) {\n  return <nav aria-label=\"breadcrumb\" data-slot=\"breadcrumb\" {...props} />\n}\n\nfunction BreadcrumbList({ className, ...props }: React.ComponentProps<'ol'>) {\n  return (\n    <ol\n      data-slot=\"breadcrumb-list\"\n      className={cn(\n        'text-muted-foreground flex flex-wrap items-center gap-1.5 text-sm break-words sm:gap-2.5',\n        className,\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction BreadcrumbItem({ className, ...props }: React.ComponentProps<'li'>) {\n  return (\n    <li\n      data-slot=\"breadcrumb-item\"\n      className={cn('inline-flex items-center gap-1.5', className)}\n      {...props}\n    />\n  )\n}\n\nfunction BreadcrumbLink({\n  asChild,\n  className,\n  ...props\n}: React.ComponentProps<'a'> & {\n  asChild?: boolean\n}) {\n  const Comp = asChild ? Slot : 'a'\n\n  return (\n    <Comp\n      data-slot=\"breadcrumb-link\"\n      className={cn('hover:text-foreground transition-colors', className)}\n      {...props}\n    />\n  )\n}\n\nfunction BreadcrumbPage({ className, ...props }: React.ComponentProps<'span'>) {\n  return (\n    <span\n      data-slot=\"breadcrumb-page\"\n      role=\"link\"\n      aria-disabled=\"true\"\n      aria-current=\"page\"\n      className={cn('text-foreground font-normal', className)}\n      {...props}\n    />\n  )\n}\n\nfunction BreadcrumbSeparator({\n  children,\n  className,\n  ...props\n}: React.ComponentProps<'li'>) {\n  return (\n    <li\n      data-slot=\"breadcrumb-separator\"\n      role=\"presentation\"\n      aria-hidden=\"true\"\n      className={cn('[&>svg]:size-3.5', className)}\n      {...props}\n    >\n      {children ?? <ChevronRight />}\n    </li>\n  )\n}\n\nfunction BreadcrumbEllipsis({\n  className,\n  ...props\n}: React.ComponentProps<'span'>) {\n  return (\n    <span\n      data-slot=\"breadcrumb-ellipsis\"\n      role=\"presentation\"\n      aria-hidden=\"true\"\n      className={cn('flex size-9 items-center justify-center', className)}\n      {...props}\n    >\n      <MoreHorizontal className=\"size-4\" />\n      <span className=\"sr-only\">More</span>\n    </span>\n  )\n}\n\nexport {\n  Breadcrumb,\n  BreadcrumbList,\n  BreadcrumbItem,\n  BreadcrumbLink,\n  BreadcrumbPage,\n  BreadcrumbSeparator,\n  BreadcrumbEllipsis,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AACA;AACA;AAAA;AAEA;;;;;AAEA,SAAS,WAAW,EAAE,GAAG,OAAoC;IAC3D,qBAAO,8OAAC;QAAI,cAAW;QAAa,aAAU;QAAc,GAAG,KAAK;;;;;;AACtE;AAEA,SAAS,eAAe,EAAE,SAAS,EAAE,GAAG,OAAmC;IACzE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kHAAE,EACX,4FACA;QAED,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,eAAe,EAAE,SAAS,EAAE,GAAG,OAAmC;IACzE,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kHAAE,EAAC,oCAAoC;QACjD,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,eAAe,EACtB,OAAO,EACP,SAAS,EACT,GAAG,OAGJ;IACC,MAAM,OAAO,UAAU,wKAAI,GAAG;IAE9B,qBACE,8OAAC;QACC,aAAU;QACV,WAAW,IAAA,kHAAE,EAAC,2CAA2C;QACxD,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,eAAe,EAAE,SAAS,EAAE,GAAG,OAAqC;IAC3E,qBACE,8OAAC;QACC,aAAU;QACV,MAAK;QACL,iBAAc;QACd,gBAAa;QACb,WAAW,IAAA,kHAAE,EAAC,+BAA+B;QAC5C,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,oBAAoB,EAC3B,QAAQ,EACR,SAAS,EACT,GAAG,OACwB;IAC3B,qBACE,8OAAC;QACC,aAAU;QACV,MAAK;QACL,eAAY;QACZ,WAAW,IAAA,kHAAE,EAAC,oBAAoB;QACjC,GAAG,KAAK;kBAER,0BAAY,8OAAC,sOAAY;;;;;;;;;;AAGhC;AAEA,SAAS,mBAAmB,EAC1B,SAAS,EACT,GAAG,OAC0B;IAC7B,qBACE,8OAAC;QACC,aAAU;QACV,MAAK;QACL,eAAY;QACZ,WAAW,IAAA,kHAAE,EAAC,2CAA2C;QACxD,GAAG,KAAK;;0BAET,8OAAC,kOAAc;gBAAC,WAAU;;;;;;0BAC1B,8OAAC;gBAAK,WAAU;0BAAU;;;;;;;;;;;;AAGhC"}},
    {"offset": {"line": 2854, "column": 0}, "map": {"version":3,"sources":["file:///Users/rahulsharma/Downloads/file-operations-app/components/ui/select.tsx"],"sourcesContent":["'use client'\n\nimport * as React from 'react'\nimport * as SelectPrimitive from '@radix-ui/react-select'\nimport { CheckIcon, ChevronDownIcon, ChevronUpIcon } from 'lucide-react'\n\nimport { cn } from '@/lib/utils'\n\nfunction Select({\n  ...props\n}: React.ComponentProps<typeof SelectPrimitive.Root>) {\n  return <SelectPrimitive.Root data-slot=\"select\" {...props} />\n}\n\nfunction SelectGroup({\n  ...props\n}: React.ComponentProps<typeof SelectPrimitive.Group>) {\n  return <SelectPrimitive.Group data-slot=\"select-group\" {...props} />\n}\n\nfunction SelectValue({\n  ...props\n}: React.ComponentProps<typeof SelectPrimitive.Value>) {\n  return <SelectPrimitive.Value data-slot=\"select-value\" {...props} />\n}\n\nfunction SelectTrigger({\n  className,\n  size = 'default',\n  children,\n  ...props\n}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {\n  size?: 'sm' | 'default'\n}) {\n  return (\n    <SelectPrimitive.Trigger\n      data-slot=\"select-trigger\"\n      data-size={size}\n      className={cn(\n        \"border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4\",\n        className,\n      )}\n      {...props}\n    >\n      {children}\n      <SelectPrimitive.Icon asChild>\n        <ChevronDownIcon className=\"size-4 opacity-50\" />\n      </SelectPrimitive.Icon>\n    </SelectPrimitive.Trigger>\n  )\n}\n\nfunction SelectContent({\n  className,\n  children,\n  position = 'popper',\n  ...props\n}: React.ComponentProps<typeof SelectPrimitive.Content>) {\n  return (\n    <SelectPrimitive.Portal>\n      <SelectPrimitive.Content\n        data-slot=\"select-content\"\n        className={cn(\n          'bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md',\n          position === 'popper' &&\n            'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',\n          className,\n        )}\n        position={position}\n        {...props}\n      >\n        <SelectScrollUpButton />\n        <SelectPrimitive.Viewport\n          className={cn(\n            'p-1',\n            position === 'popper' &&\n              'h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1',\n          )}\n        >\n          {children}\n        </SelectPrimitive.Viewport>\n        <SelectScrollDownButton />\n      </SelectPrimitive.Content>\n    </SelectPrimitive.Portal>\n  )\n}\n\nfunction SelectLabel({\n  className,\n  ...props\n}: React.ComponentProps<typeof SelectPrimitive.Label>) {\n  return (\n    <SelectPrimitive.Label\n      data-slot=\"select-label\"\n      className={cn('text-muted-foreground px-2 py-1.5 text-xs', className)}\n      {...props}\n    />\n  )\n}\n\nfunction SelectItem({\n  className,\n  children,\n  ...props\n}: React.ComponentProps<typeof SelectPrimitive.Item>) {\n  return (\n    <SelectPrimitive.Item\n      data-slot=\"select-item\"\n      className={cn(\n        \"focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2\",\n        className,\n      )}\n      {...props}\n    >\n      <span className=\"absolute right-2 flex size-3.5 items-center justify-center\">\n        <SelectPrimitive.ItemIndicator>\n          <CheckIcon className=\"size-4\" />\n        </SelectPrimitive.ItemIndicator>\n      </span>\n      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>\n    </SelectPrimitive.Item>\n  )\n}\n\nfunction SelectSeparator({\n  className,\n  ...props\n}: React.ComponentProps<typeof SelectPrimitive.Separator>) {\n  return (\n    <SelectPrimitive.Separator\n      data-slot=\"select-separator\"\n      className={cn('bg-border pointer-events-none -mx-1 my-1 h-px', className)}\n      {...props}\n    />\n  )\n}\n\nfunction SelectScrollUpButton({\n  className,\n  ...props\n}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {\n  return (\n    <SelectPrimitive.ScrollUpButton\n      data-slot=\"select-scroll-up-button\"\n      className={cn(\n        'flex cursor-default items-center justify-center py-1',\n        className,\n      )}\n      {...props}\n    >\n      <ChevronUpIcon className=\"size-4\" />\n    </SelectPrimitive.ScrollUpButton>\n  )\n}\n\nfunction SelectScrollDownButton({\n  className,\n  ...props\n}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {\n  return (\n    <SelectPrimitive.ScrollDownButton\n      data-slot=\"select-scroll-down-button\"\n      className={cn(\n        'flex cursor-default items-center justify-center py-1',\n        className,\n      )}\n      {...props}\n    >\n      <ChevronDownIcon className=\"size-4\" />\n    </SelectPrimitive.ScrollDownButton>\n  )\n}\n\nexport {\n  Select,\n  SelectContent,\n  SelectGroup,\n  SelectItem,\n  SelectLabel,\n  SelectScrollDownButton,\n  SelectScrollUpButton,\n  SelectSeparator,\n  SelectTrigger,\n  SelectValue,\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAGA;AACA;AAAA;AAAA;AAEA;AANA;;;;;AAQA,SAAS,OAAO,EACd,GAAG,OAC+C;IAClD,qBAAO,8OAAC,0KAAoB;QAAC,aAAU;QAAU,GAAG,KAAK;;;;;;AAC3D;AAEA,SAAS,YAAY,EACnB,GAAG,OACgD;IACnD,qBAAO,8OAAC,2KAAqB;QAAC,aAAU;QAAgB,GAAG,KAAK;;;;;;AAClE;AAEA,SAAS,YAAY,EACnB,GAAG,OACgD;IACnD,qBAAO,8OAAC,2KAAqB;QAAC,aAAU;QAAgB,GAAG,KAAK;;;;;;AAClE;AAEA,SAAS,cAAc,EACrB,SAAS,EACT,OAAO,SAAS,EAChB,QAAQ,EACR,GAAG,OAGJ;IACC,qBACE,8OAAC,6KAAuB;QACtB,aAAU;QACV,aAAW;QACX,WAAW,IAAA,kHAAE,EACX,gzBACA;QAED,GAAG,KAAK;;YAER;0BACD,8OAAC,0KAAoB;gBAAC,OAAO;0BAC3B,cAAA,8OAAC,2OAAe;oBAAC,WAAU;;;;;;;;;;;;;;;;;AAInC;AAEA,SAAS,cAAc,EACrB,SAAS,EACT,QAAQ,EACR,WAAW,QAAQ,EACnB,GAAG,OACkD;IACrD,qBACE,8OAAC,4KAAsB;kBACrB,cAAA,8OAAC,6KAAuB;YACtB,aAAU;YACV,WAAW,IAAA,kHAAE,EACX,ijBACA,aAAa,YACX,mIACF;YAEF,UAAU;YACT,GAAG,KAAK;;8BAET,8OAAC;;;;;8BACD,8OAAC,8KAAwB;oBACvB,WAAW,IAAA,kHAAE,EACX,OACA,aAAa,YACX;8BAGH;;;;;;8BAEH,8OAAC;;;;;;;;;;;;;;;;AAIT;AAEA,SAAS,YAAY,EACnB,SAAS,EACT,GAAG,OACgD;IACnD,qBACE,8OAAC,2KAAqB;QACpB,aAAU;QACV,WAAW,IAAA,kHAAE,EAAC,6CAA6C;QAC1D,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,WAAW,EAClB,SAAS,EACT,QAAQ,EACR,GAAG,OAC+C;IAClD,qBACE,8OAAC,0KAAoB;QACnB,aAAU;QACV,WAAW,IAAA,kHAAE,EACX,6aACA;QAED,GAAG,KAAK;;0BAET,8OAAC;gBAAK,WAAU;0BACd,cAAA,8OAAC,mLAA6B;8BAC5B,cAAA,8OAAC,qNAAS;wBAAC,WAAU;;;;;;;;;;;;;;;;0BAGzB,8OAAC,8KAAwB;0BAAE;;;;;;;;;;;;AAGjC;AAEA,SAAS,gBAAgB,EACvB,SAAS,EACT,GAAG,OACoD;IACvD,qBACE,8OAAC,+KAAyB;QACxB,aAAU;QACV,WAAW,IAAA,kHAAE,EAAC,iDAAiD;QAC9D,GAAG,KAAK;;;;;;AAGf;AAEA,SAAS,qBAAqB,EAC5B,SAAS,EACT,GAAG,OACyD;IAC5D,qBACE,8OAAC,oLAA8B;QAC7B,aAAU;QACV,WAAW,IAAA,kHAAE,EACX,wDACA;QAED,GAAG,KAAK;kBAET,cAAA,8OAAC,qOAAa;YAAC,WAAU;;;;;;;;;;;AAG/B;AAEA,SAAS,uBAAuB,EAC9B,SAAS,EACT,GAAG,OAC2D;IAC9D,qBACE,8OAAC,sLAAgC;QAC/B,aAAU;QACV,WAAW,IAAA,kHAAE,EACX,wDACA;QAED,GAAG,KAAK;kBAET,cAAA,8OAAC,2OAAe;YAAC,WAAU;;;;;;;;;;;AAGjC"}}]
}